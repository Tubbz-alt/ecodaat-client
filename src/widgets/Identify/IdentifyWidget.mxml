<?xml version="1.0" encoding="utf-8"?>
<!--
	////////////////////////////////////////////////////////////////////////////////
	//
	// Developed initially by esri and continually enhanced by Robert Scheitlin
	//
	////////////////////////////////////////////////////////////////////////////////
-->
<viewer:BaseWidget xmlns:fx="http://ns.adobe.com/mxml/2009"
				   xmlns:s="library://ns.adobe.com/flex/spark"
				   xmlns:mx="library://ns.adobe.com/flex/mx"
				   xmlns:esri="http://www.esri.com/2008/ags"
				   xmlns:viewer="com.esri.viewer.*"
				   xmlns:Ident="widgets.Identify.*"
				   layout="absolute"
				   widgetConfigLoaded="init()"
				   currentState="StateIdentify">
				   
	<fx:Declarations>
		<s:GlowFilter id="glowFilter"
					  alpha="1"
					  color="{getStyle('focusColor')}"
					  inner="true"
					  strength="2"/>
		<esri:GeometryService id="geometryService"
							  fault="geometryService_faultHandler(event)"
							  url="http://tasks.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer"/>
	</fx:Declarations>
	
	<viewer:states>
		<s:State name="StateIdentify"/>
		<s:State name="resultsList"/>
	</viewer:states>
	<viewer:transitions>
		<s:Transition autoReverse="true" toState="*">
			<s:Fade targets="{[StateIdentify,resultsList]}"/>
		</s:Transition>
	</viewer:transitions>
	<fx:Script>
		<![CDATA[
			import com.esri.ags.Graphic;
			import com.esri.ags.Map;
			import com.esri.ags.SpatialReference;
			import com.esri.ags.TimeExtent;
			import com.esri.ags.events.DrawEvent;
			import com.esri.ags.events.IdentifyEvent;
			import com.esri.ags.geometry.Extent;
			import com.esri.ags.geometry.Geometry;
			import com.esri.ags.geometry.MapPoint;
			import com.esri.ags.geometry.Polygon;
			import com.esri.ags.geometry.Polyline;
			import com.esri.ags.layers.ArcGISDynamicMapServiceLayer;
			import com.esri.ags.layers.GraphicsLayer;
			import com.esri.ags.layers.Layer;
			import com.esri.ags.portal.PopUpRenderer;
			import com.esri.ags.portal.supportClasses.PopUpInfo;
			import com.esri.ags.symbols.PictureMarkerSymbol;
			import com.esri.ags.symbols.SimpleFillSymbol;
			import com.esri.ags.symbols.SimpleLineSymbol;
			import com.esri.ags.symbols.SimpleMarkerSymbol;
			import com.esri.ags.symbols.Symbol;
			import com.esri.ags.tasks.GeometryServiceSingleton;
			import com.esri.ags.tasks.IdentifyTask;
			import com.esri.ags.tasks.supportClasses.IdentifyParameters;
			import com.esri.ags.tasks.supportClasses.IdentifyResult;
			import com.esri.ags.tools.DrawTool;
			import com.esri.ags.utils.JSONUtil;
			import com.esri.viewer.AppEvent;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.rpc.http.HTTPService;
			import mx.utils.StringUtil;
			
			import spark.components.supportClasses.ItemRenderer;
			
			//labels
			private var identifyLabel:String;
			
			private var resultsLabel:String;
			
			[Bindable] private var descriptionLabel:String;
			
			private var identifyLayerOption:String;
			
			private var identifyTolerance:Number = 3;
			
			[Bindable] private var pointLabel:String;
			
			[Bindable] private var lineLabel:String;
			
			[Bindable] private var rectLabel:String;
			
			[Bindable] private var polyLabel:String;
			
			[Bindable] private var clearLabel:String;	
			
			private var loadingLabel:String;	
			
			private var gra:Graphic;
			
			private var lastTool:String;
			
			[Bindable] private var msgVisible:Boolean = false;
			
			[Bindable] private var enableLine:Boolean = false;
			
			[Bindable] private var enableExtent:Boolean = false;
			
			[Bindable] private var enablePoly:Boolean = false;
			
			[Bindable] private var enableMoverGra:Boolean = false;
			
			[Bindable] private var enableMoverRec:Boolean = false;
			
			private var zoomScale:Number = 5000;
			
			private var keepActive:Boolean;
			
			private var returnGeomForZoom:Boolean;
			
			private var onlylistedlayers:Boolean;
			
			private var zoom2Msg:String;
			
			private var graphicsLayer:GraphicsLayer;
			
			private var identMarkerSymbol:Symbol;
			
			private var identLineSymbol:Symbol;
			
			private var identFillSymbol:Symbol;
			
			private var identPicSymbol:Symbol;
			
			private var identifyGeom:Geometry;
			
			[Bindable]private var identifyArrayCollection:ArrayCollection = new ArrayCollection();
			
			private var configIdentFields:Array;
			
			private var configIdentProxyLayers:Array;
			
			private const ICON_URL:String = "assets/images/";
			
			private var proxyURL:String;
			
			private var selectedDrawingIcon:Image;
			
			private var popUpRenderer:PopUpRenderer = new PopUpRenderer();
			
			private var betaReturnGeometryFix:Boolean;
			
			[Bindable] private var autoActivatedTool:String;
			
			private var drawSymbol:Symbol;
			
			private var useMapTime:Boolean;
			private var tokeny:String;
			
			private function init():void
			{
				if (configXML){
					if (GeometryServiceSingleton.instance.url){ // using GeometryServiceSingleton
						geometryService.url = GeometryServiceSingleton.instance.url;
						geometryService.token = GeometryServiceSingleton.instance.token;
						geometryService.proxyURL = GeometryServiceSingleton.instance.proxyURL;
					}
					
					//labels
					zoom2Msg = configXML.labels.zoom2message || "Click to Zoom to Point";
					identifyLabel = configXML.labels.identifylabel || "Identify";
					resultsLabel = configXML.labels.resultslabel || "Results";
					descriptionLabel = configXML.labels.descriptionlabel || "Use the identify tool to identify features on the map:";
					pointLabel = configXML.labels.pointlabel || "Identify Point";
					lineLabel = configXML.labels.linelabel || "Identify Polyline";
					rectLabel = configXML.labels.rectlabel || "Identify Rectangle";
					polyLabel = configXML.labels.polylabel || "Identify Polygon";
					clearLabel = configXML.labels.clearlabel || "Clear";
					loadingLabel = configXML.labels.loadinglabel || "Loading...";
					tokeny = configXML.token || "";
					enableMoverRec = configXML.enablemouseoverrecordinfo && configXML.enablemouseoverrecordinfo == "true";
					enableMoverGra = configXML.enablemouseovergraphicsinfo && configXML.enablemouseovergraphicsinfo == "true";
					enableLine = configXML.enablelineselect && configXML.enablelineselect == "true";
					enableExtent = configXML.enbleextentselect && configXML.enbleextentselect == "true";
					enablePoly = configXML.enablepolyselect && configXML.enablepolyselect == "true";
					keepActive = configXML.keepidentifyactive && configXML.keepidentifyactive == "true";
					onlylistedlayers = configXML.layers.@onlythese && configXML.layers.@onlythese == "true";
					identifyLayerOption = configXML.identifylayeroption || IdentifyParameters.LAYER_OPTION_VISIBLE;
					returnGeomForZoom = configXML.returngeometryforzoom && configXML.returngeometryforzoom == "true";
					autoActivatedTool = configXML.autoactivatedtool || "";
					betaReturnGeometryFix = configXML.betareturngeometryfix && configXML.betareturngeometryfix =="true";
					if (Number(configXML.identifytolerance) > 0)
						identifyTolerance = Number(configXML.identifytolerance);				
					if (Number(configXML.defaultzoomscale) > 0)
						zoomScale = Number(configXML.defaultzoomscale);
					useMapTime = configXML.usemaptime && configXML.usemaptime == "true"; 
					
					//HAB:get the proxy URL from the config file
					proxyURL = configXML.httpproxy;
					
					/*HAB:loop thru the layers that need a proxy and add them to 
					the proxy layer list array*/
					var proxyLyrList:XMLList = configXML..proxylayer;
					configIdentProxyLayers = [];
					for (var j:Number = 0; j < proxyLyrList.length(); j++){
						var identProxyLayers:Object = 
						{
							name:proxyLyrList[j].name
						}
						configIdentProxyLayers.push(identProxyLayers);
					}
					
					configIdentFields = [];
					var lyrList:XMLList = configXML..layer;
					for (var i:Number = 0; i < lyrList.length(); i++){
						var lyrLabel:String = lyrList[i].name;
						var lyrLinks:Array = [];
						var lyrLinkList:XMLList = lyrList[i]..link;
						for (var l:Number = 0; l < lyrLinkList.length(); l++){
							var lyrLinkAlias:String = lyrLinkList[l].@alias || "";
							var lyrLinkField:String = lyrLinkList[l].@field || "";
							var lyrLinkPre:String = lyrLinkList[l].linkprefix || "";
							var lyrLinkSuffix:String = lyrLinkList[l].linksuffix || "";
							var lyrLinkIconField:String = lyrLinkList[l].iconfield || "";
							var lyrLinkIconPre:String = lyrLinkList[l].iconprefix || "";
							var lyrLinkIconSuffix:String = lyrLinkList[l].iconsuffix || "";
							var incLinkInRslts:Boolean = lyrLinkList[l].@includeinresults && lyrLinkList[l].@includeinresults == "true";
							var linkObj:Object = {
								field: lyrLinkField,
								pre: lyrLinkPre,
								suf: lyrLinkSuffix,
								inc: incLinkInRslts,
								alias: lyrLinkAlias,
								icon: lyrLinkIconField,
								iconpre: lyrLinkIconPre,
								iconsuf: lyrLinkIconSuffix
							}
							lyrLinks.push(linkObj);
						}
						var lyrFields:String = lyrList[i].fields;
						var lyrZoomScale:Number = Number(lyrList[i].zoomscale);
						var lyrForceScale:Boolean = Boolean(lyrList[i].forcescale);
						if(lyrZoomScale == 0)
							lyrZoomScale = zoomScale;
						var identLayer:Object = 
						{
							label: lyrLabel,
							links: lyrLinks,
							fields: lyrFields,
							zoomscale: lyrZoomScale,
							forcescale: lyrForceScale
						}
						configIdentFields.push(identLayer);
					}
				}
				
				//marker symbol
				const identPicSymbolURL:String = configXML.symbols.picturemarkersymbol.@url || widgetIcon;
				const identPicSymbolHeight:Number = (configXML.symbols.picturemarkersymbol.@height[0] != null) ? configXML.symbols.picturemarkersymbol.@height : 30;
				const identPicSymbolWidth:Number = (configXML.symbols.picturemarkersymbol.@width[0] != null) ? configXML.symbols.picturemarkersymbol.@width : 30;
				const identPicSymbolXOffset:Number = configXML.symbols.picturemarkersymbol.@xoffset || 0;
				const identPicSymbolYOffset:Number = configXML.symbols.picturemarkersymbol.@yoffset || 0;
				identPicSymbol = new PictureMarkerSymbol(identPicSymbolURL, identPicSymbolWidth, identPicSymbolHeight, identPicSymbolXOffset, identPicSymbolYOffset);
					
				const identMarkerSymbolStyle:String = configXML.symbols.simplemarkersymbol.@style || "circle";
				const identMarkerSymbolSize:Number = (configXML.symbols.simplemarkersymbol.@size[0] != null) ? configXML.symbols.simplemarkersymbol.@size : 12;
				const identMarkerSymbolColor:uint = (configXML.symbols.simplemarkersymbol.@color[0] != null) ? configXML.symbols.simplemarkersymbol.@color : 0x448ccb;
				const identMarkerSymbolAlpha:Number = (configXML.symbols.simplemarkersymbol.@alpha[0] != null) ? configXML.symbols.simplemarkersymbol.@alpha : 0.8;
				const identMarkerSymbolXOffset2:Number = configXML.symbols.simplemarkersymbol.@xoffset || 0;
				const identMarkerSymbolYOffset2:Number = configXML.symbols.simplemarkersymbol.@yoffset || 0;
				const identMarkerSymbolAngle:Number = configXML.symbols.simplemarkersymbol.@angle || 0;
				const identMarkerSymbolOutlineStyle:String = configXML.symbols.simplemarkersymbol.outline.@style || "solid";
				const identMarkerSymbolOutlineColor:uint = (configXML.symbols.simplemarkersymbol.outline.@color[0] != null) ? configXML.symbols.simplemarkersymbol.outline.@color : 0xffffff;
				const identMarkerSymbolOutlineAlpha:Number = (configXML.symbols.simplemarkersymbol.outline.@alpha[0] != null) ? configXML.symbols.simplemarkersymbol.outline.@alpha : 0.8;
				const identMarkerSymbolOutlineWidth:Number = (configXML.symbols.simplemarkersymbol.outline.@width[0] != null) ? configXML.symbols.simplemarkersymbol.outline.@width : 2;
				identMarkerSymbol = new SimpleMarkerSymbol(identMarkerSymbolStyle,identMarkerSymbolSize,identMarkerSymbolColor,identMarkerSymbolAlpha,identMarkerSymbolXOffset2,identMarkerSymbolYOffset2,identMarkerSymbolAngle,new SimpleLineSymbol(identMarkerSymbolOutlineStyle, identMarkerSymbolOutlineColor, identMarkerSymbolOutlineAlpha, identMarkerSymbolOutlineWidth));
				
				//line symbol
				const identLineSymbolColor:uint = (configXML.symbols.simplelinesymbol.@color[0] != null) ? configXML.symbols.simplelinesymbol.@color : 0x448ccb;
				const identLineSymbolAlpha:Number = (configXML.symbols.simplelinesymbol.@alpha[0] != null) ? configXML.symbols.simplelinesymbol.@alpha : 0.8;
				const identLineSymbolWidth:Number = (configXML.symbols.simplelinesymbol.@width[0] != null) ? configXML.symbols.simplelinesymbol.@width : 2;
				identLineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, identLineSymbolColor, identLineSymbolAlpha, identLineSymbolWidth);
				
				// fill symbol
				const identFillSymbolColor:uint = (configXML.symbols.simplefillsymbol.@color[0] != null) ? configXML.symbols.simplefillsymbol.@color : 0x448ccb;
				const identFillSymbolAlpha:Number = (configXML.symbols.simplefillsymbol.@alpha[0] != null) ? configXML.symbols.simplefillsymbol.@alpha : 0.5; 
				const identFillSymbolOutlineColor:uint = (configXML.symbols.simplefillsymbol.outline.@color[0] != null) ? configXML.symbols.simplefillsymbol.outline.@color : 0x448ccb;
				const identFillSymbolOutlineAlpha:Number = (configXML.symbols.simplefillsymbol.outline.@alpha[0] != null) ? configXML.symbols.simplefillsymbol.outline.@alpha : 0.8;
				const identFillSymbolOutlineWidth:Number = (configXML.symbols.simplefillsymbol.outline.@width[0] != null) ? configXML.symbols.simplefillsymbol.outline.@width : 2;
				identFillSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, identFillSymbolColor, identFillSymbolAlpha, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, identFillSymbolOutlineColor, identFillSymbolOutlineAlpha, identFillSymbolOutlineWidth));
				
				graphicsLayer = new GraphicsLayer();
				graphicsLayer.symbol = identPicSymbol;
				map.addLayer(graphicsLayer);
				
				wTemplate.addTitlebarButton(ICON_URL + "i_info.png", identifyLabel, showStateIdentify);
				wTemplate.addTitlebarButton(ICON_URL + "i_table.png", resultsLabel, showStateResults);
				AppEvent.addListener(AppEvent.DATA_PUBLISH, sharedDataUpdated);
				
				if (autoActivatedTool != "" )
					activateIdentifyTool(null, autoActivatedTool);
			}
			
			private function activateIdentifyTool(event:MouseEvent, lTool:String = ""):void
			{
				addSharedData("Deactivate_DrawTool", null); // to be able to deactivate drawTool on other widgets
				
				// apply glow
				if(event){
					//Allow button to act as toggle buttons
					if(lastTool == Image(event.currentTarget).name){
						clearSelectionFilter();
						setMapAction(null, null, null, null);
						hideInfoWindow();
						setMapNavigation(null, null);
						lastTool = "";
						return;
					}else{
						selectedDrawingIcon = Image(event.currentTarget);
					}
				}else{
					switch(lTool){
						case DrawTool.EXTENT :{
							selectedDrawingIcon = iDrawExt;
							break;
						}
						case DrawTool.POLYGON :{
							//selectedDrawingIcon = iDrawPoly;
							break;
						}
						case DrawTool.MAPPOINT :{
							selectedDrawingIcon = iDrawPnt;
							break;
						}
						case DrawTool.POLYLINE :{
							selectedDrawingIcon = iDrawLine;
							break;
						}
						default:{
							selectedDrawingIcon = iDrawPnt;
						}
					}
					
				}
				clearSelectionFilter();
				selectedDrawingIcon.filters = [ glowFilter ];
				
				var status:String;
				var value:String = selectedDrawingIcon.name;
				
				lastTool = selectedDrawingIcon.name;
				//setMapNavigation("none", "");
				switch (value){
					case DrawTool.MAPPOINT:{
						status = pointLabel;
						setMapAction(DrawTool.MAPPOINT, status, identMarkerSymbol, drawEnd, true);
						break;
					}
					case DrawTool.POLYLINE:{
						status = lineLabel;
						setMapAction(DrawTool.POLYLINE, status, identLineSymbol, drawEnd, true);
						break;
					}
					case DrawTool.EXTENT:{
						status = rectLabel;
						setMapAction(DrawTool.EXTENT, status, identFillSymbol, drawEnd, false);
						break;
					}
					case DrawTool.POLYGON:{
						status = polyLabel;
						setMapAction(DrawTool.POLYGON, status, identFillSymbol, drawEnd, false);
						break;
					}
				}
			}
			
			private function drawEnd(event:DrawEvent):void
			{
				clear();
				if(keepActive){
					activateIdentifyTool(null, lastTool);
				}else{
					event.target.deactivate();
					if (selectedDrawingIcon){
						selectedDrawingIcon.filters = [];
						selectedDrawingIcon = null;
					}
					lastTool = "";
				}
				identifyGeom = event.graphic.geometry;
				identifyFeatures(identifyGeom);
			}
			
			//get geom center
			private function getGeomCenter(geometry:Geometry):MapPoint
			{
				var point:MapPoint;
				if (geometry){
					switch (geometry.type){
						case Geometry.MAPPOINT:{
							point = geometry as MapPoint;
							break;
						}
						case Geometry.POLYLINE:{
							const pl:Polyline = geometry as Polyline;
							pl.spatialReference =  map.spatialReference;
							const pathCount:Number = pl.paths.length;
							const pathIndex:int = int((pathCount / 2) - 1);
							const midPath:Array = pl.paths[pathIndex];
							const ptCount:Number = midPath.length;
							const ptIndex:int = int((ptCount / 2) - 1);
							point = pl.getPoint(pathIndex, ptIndex);
							break;
						}
						case Geometry.POLYGON:{
							const poly:Polygon = geometry as Polygon;
							point = poly.extent.center;
							break;
						}
						case Geometry.EXTENT:{
							const ext:Extent = geometry as Extent;
							point = ext.center;
							break;
						}
					}
				}
				return point;
			}
			
			//identify features
			private function identifyFeatures(geom:Geometry):void
			{
				var identifyParams:IdentifyParameters = new IdentifyParameters();
				identifyParams.returnGeometry = returnGeomForZoom;
				identifyParams.tolerance = identifyTolerance;
				identifyParams.geometry = geom;
				identifyParams.width = map.width;
				identifyParams.height = map.height;
				identifyParams.mapExtent = map.extent;
				identifyParams.spatialReference = map.spatialReference;
				var mt:TimeExtent = map.timeExtent;
				if (useMapTime && map.timeExtent != null)
					identifyParams.timeExtent = new TimeExtent(mt.startTime, mt.endTime);
				if(betaReturnGeometryFix){
					var geomString:String = JSONUtil.encode(geom).replace(',"spatialReference":{"wkid":' + geom.spatialReference.wkid + '}','');
					var idURL:String = "?geometryType=" + geom.type + "&geometry=" + geomString;
					idURL += "&sr=" + map.spatialReference.wkid.toString() + "&layers="
					var idURL2:String = "&tolerance=" + identifyTolerance.toString() + "&mapExtent=" + map.extent.xmin.toString() + "," + map.extent.ymin.toString() + "," +  map.extent.xmax.toString() + "," +  map.extent.ymax.toString();
					idURL2 += "&imageDisplay=" + map.width.toString() + "," + map.height.toString() + ",96" + "&returnGeometry=" + returnGeomForZoom.valueOf().toString() + "&f=json";
				}
				for (var i:Number = map.layerIds.length -1; i >= 0; i--){
					identifyParams.layerOption = identifyLayerOption;
					var layer:Layer = map.getLayer(map.layerIds[i]);
					
					identifyParams.layerIds = null;
					var url:String = "";
					//HAB:Does this layer require a proxy???
					var useProxy:Boolean = false;
					//HAB:loop thru proxy layer list and determine which layer needs a proxy
					for(var p:int=0; p<configIdentProxyLayers.length; p++){
						//HAB:set the proxy flag if needed
						if (layer.name == configIdentProxyLayers[p].name)
							useProxy = true;
					}
					
					if (layer is ArcGISDynamicMapServiceLayer){
						var dynamicLayer:ArcGISDynamicMapServiceLayer = layer as ArcGISDynamicMapServiceLayer;
						url = dynamicLayer.url;
						if(identifyLayerOption == "visible"){
							if(dynamicLayer.visible == false){
								url="";
							}else{
								if(dynamicLayer.visibleLayers){
									identifyParams.layerIds = new Array();
									for (var j:Number = 0; j < dynamicLayer.visibleLayers.length; j++){
										if (dynamicLayer.layerInfos[dynamicLayer.visibleLayers[j]] && 
											!dynamicLayer.layerInfos[dynamicLayer.visibleLayers[j]].subLayerIds){
											identifyParams.layerIds.push(dynamicLayer.visibleLayers[j]);
										}
									}
									identifyParams.layerOption = "all";
								}
							}	
						}
					}
					
					if(url){
						if(betaReturnGeometryFix){
							var visString:String = "";
							if(identifyParams.layerIds){
								visString += ":";
								for(var v:int=0; v<identifyParams.layerIds.length; v++){
									if(v>0)
										visString += ","
									visString += identifyParams.layerIds[v].toString();
								}
							}
							var cIdURL:String = url + "/identify" + idURL + identifyLayerOption + visString + idURL2;
							var iService:HTTPService = new HTTPService();
							iService.url = cIdURL;
							iService.resultFormat = "text";
							iService.addEventListener(ResultEvent.RESULT, buildIdResults);
							iService.addEventListener(FaultEvent.FAULT, onFault);
							iService.send();
							showMessage(loadingLabel, true); 
							showStateResults();
						}else{
							var identifyTask:IdentifyTask = new IdentifyTask(url);
							//HAB:apply proxy if needed
							if(useProxy)identifyTask.proxyURL = proxyURL;
							identifyTask.addEventListener(IdentifyEvent.EXECUTE_COMPLETE, onResult);
							if(tokeny !=""){
								identifyTask.token = tokeny;
							}
							
							identifyTask.addEventListener(FaultEvent.FAULT, onFault);
							identifyTask.execute(identifyParams);
							showMessage(loadingLabel, true); 
							showStateResults();
						}						    
					}
				}
			}			
			
			private function buildIdResults(event:ResultEvent):void
			{
				var rawData:String = String(event.result);
				var data:Object = JSONUtil.decode(rawData);
				var retArray:Array = [];
				if(data.error){
					//do nothing;
				}else{
					for each( var idObj:Object in data.results){
						var idResult:IdentifyResult = new IdentifyResult();
						idResult.displayFieldName = idObj.displayFieldName;
						idResult.layerId = idObj.layerId;
						idResult.layerName = idObj.layerName;
						idResult.feature = buildGra(idObj);
						retArray.push(idResult);
					}
				}
				function buildGra(obj:Object):Graphic
				{
					var gra:Graphic;
					switch(obj.geometryType){
						case Geometry.MAPPOINT:{
							var mp:MapPoint = new MapPoint(obj.geometry.x, obj.geometry.y, new SpatialReference(obj.geometry.spatialReference.wkid));
							gra = new Graphic(mp);
							gra.attributes = obj.attributes;
							break;
						}
						case Geometry.POLYGON:{
							var mPoly:Polygon = new Polygon(null);
							for (var i2:int = obj.geometry.rings.length - 1; i2 >= 0; i2--){
								var ringArray:Array = [];
								for (var j1:int = 0; j1 < obj.geometry.rings[i2].length; j1++){
									var mpStr:String = obj.geometry.rings[i2][j1];
									var xyArr:Array = mpStr.split(",")
									var mp2:MapPoint = new MapPoint(xyArr[0], xyArr[1]);
									mp2.spatialReference = new SpatialReference(obj.geometry.spatialReference.wkid);
									ringArray.push(mp2);
								}
								mPoly.addRing(ringArray);
							}
							mPoly.spatialReference = new SpatialReference(obj.geometry.spatialReference.wkid);
							
							gra = new Graphic(mPoly);
							gra.attributes = obj.attributes;
							break;
						}
						case Geometry.EXTENT:{
							var ext:Extent = new Extent(obj.geometry.xmin, obj.geometry.ymin, obj.geometry.xmax, obj.geometry.ymax, new SpatialReference(obj.geometry.spatialReference.wkid));
							gra = new Graphic(ext);
							gra.attributes = obj.attributes;
							break;
						}
						case Geometry.POLYLINE:{
							var pLine:Polyline = new Polyline(null);
							for (var i3:int = obj.geometry.paths.length - 1; i3 >= 0; i3--){
								var pathArray:Array = [];
								for (var j2:int = 0; j2 < obj.geometry.paths[i3].length; j2++){
									var mpStr2:String = obj.geometry.paths[i3][j2];
									var xyArr2:Array = mpStr2.split(",")
									var mp3:MapPoint = new MapPoint(xyArr2[0], xyArr2[1]);
									mp3.spatialReference = new SpatialReference(obj.geometry.spatialReference.wkid);
									pathArray.push(mp3);
								}
								pLine.addPath(pathArray);
							}
							gra = new Graphic(pLine);
							gra.attributes = obj.attributes;
							break;
						}
					}
					return gra;
				}
				onResult(new IdentifyEvent("",retArray));
			}
			
			private function onResult(event:IdentifyEvent):void                
			{
				var identifyResults:Array = event.identifyResults;
				if(!identifyArrayCollection)
					identifyArrayCollection = new ArrayCollection();
				for each (var identifyResult:IdentifyResult in identifyResults){
					var title:String = identifyResult.layerName;
					var obj:Object = identifyResult.feature.attributes;
					var content:String = "";
					var fld:String;
					var value:String;
					var identFields:String = "";
					var identLinks:Array = [];
					var lyrIdLinks:Array = [];
					var identZoom:Number = 0;
					var identForceScale:Boolean = false;
					var idResult:IdResult = new IdResult();
					
					for(var i:int=0; i<configIdentFields.length; i++){
						if (identifyResult.layerName == configIdentFields[i].label){
							identLinks = configIdentFields[i].links;
							identFields = configIdentFields[i].fields;
							identZoom = configIdentFields[i].zoomscale;
							identForceScale = configIdentFields[i].forcescale;
						}
					}
					
					if(identFields != "") {
						var fldArr:Array = StringUtil.trimArrayElements(identFields,",").split(",");
						var excludeLinkinResults:ArrayCollection = new ArrayCollection();
						for (var a:int = 0; a < identLinks.length; a++){
							var link:String = "";
							var linkicon:String = "";
							var alias:String = "";
							
							for (var f2:Number = 0; f2 < fldArr.length; f2++) {
								var val:String;
								try{	        	    		       
									val = obj[fldArr[f2]] ? String(obj[fldArr[f2]]) : "";
								} catch (error: Error){
									val = "";
								}
								if (fldArr[f2].toUpperCase() == identLinks[a].field.toUpperCase() || fldArr[f2].toUpperCase() == identLinks[a].icon.toUpperCase()){
									if (fldArr[f2].toUpperCase() == identLinks[a].field.toUpperCase()){
										if(identLinks[a].alias)
											alias = identLinks[a].alias;
										//Add the field name if the link field is to be included in the
										//results as well as used for a link.
										if(!identLinks[a].inc)
											excludeLinkinResults.addItem(identLinks[a].field.toUpperCase());
										//concatenate
										if(val != "" && val != "Null")
											link = identLinks[a].pre + val + identLinks[a].suf;
										if( identLinks[a].iconpre != "" || identLinks[a].iconsuf != "")
											linkicon = identLinks[a].iconpre + identLinks[a].iconsuf;
										if(fldArr[f2].toUpperCase() == identLinks[a].icon.toUpperCase()){
											//concatenate
											if(val != "" && val != "Null"){
												linkicon = identLinks[a].iconpre + val + identLinks[a].iconsuf;
											}else if(identLinks[a].iconpre != "" || identLinks[a].iconsuf != ""){
												linkicon = identLinks[a].iconpre + val + identLinks[a].iconsuf;
											}
										}
									}
								}
							}
							var lObj:Object ={
								link: link,
								icon: linkicon,
								alias: alias
							}
							lyrIdLinks.push(lObj);
						}
						
						for (var f:Number = 0; f < fldArr.length; f++) {
							try{	        	    		       
								value = obj[fldArr[f]] ? String(obj[fldArr[f]]) : "";
							} catch (error: Error){
								value = "";
							}
							value.replace(/</g,"&gt;").replace(/>/g,"&lt;");
							
							if(!excludeLinkinResults.contains(fldArr[f].toUpperCase()))
								content += "<b>" + fldArr[f] + ":  </b>"+ value + "<br \>";
						}
						
						idResult.icon = widgetIcon;
						idResult.title = identifyResult.layerName;
						idResult.content = content.substr(0,content.length - 5);
						idResult.links = lyrIdLinks;
						if(identifyGeom is MapPoint){
							idResult.point = identifyGeom as MapPoint
						}else{
							idResult.point = (returnGeomForZoom) ? getGeomCenter(identifyResult.feature.geometry) : getGeomCenter(identifyGeom);
						}
						idResult.geometry = (returnGeomForZoom) ? identifyResult.feature.geometry : identifyGeom;
						idResult.zoomScale = identZoom;
						idResult.zoom2msg = zoom2Msg;
						var iGra:Graphic = new Graphic(idResult.geometry);
						switch (idResult.geometry.type){
							case Geometry.MAPPOINT:{
								iGra.symbol = identMarkerSymbol;
								break;
							}
							case Geometry.POLYLINE:{
								iGra.symbol = identLineSymbol;
								break;
							}
							case Geometry.POLYGON:
							case Geometry.EXTENT:{
								iGra.symbol = identFillSymbol;
								break;
							}
						}
						
						idResult.graphic = iGra;
						idResult.forceScale = identForceScale;
						identifyArrayCollection.addItem(idResult);
						if(enableMoverGra)
							iGra.addEventListener(MouseEvent.ROLL_OVER, mouseOverGraphic);
						iGra.attributes = idResult;
						if(returnGeomForZoom)
							graphicsLayer.add(iGra);
						var popUpInfo : PopUpInfo = new PopUpInfo();
						popUpInfo.title = "{title}";
						popUpInfo.description = "{content}";
						var infoWindowRenderer:ClassFactory = new ClassFactory(PopUpRenderer);
						infoWindowRenderer.properties = {popUpInfo: popUpInfo};
						iGra.infoWindowRenderer = infoWindowRenderer;
					}else{
						if(onlylistedlayers == false){
							for (fld in obj){
								try{
									value = obj[fld] ? String(obj[fld]) : "";
								} catch (error: Error) {
									value = "";
								}
								value.replace(/</g,"&gt;").replace(/>/g,"&lt;");
								content += "<b>" + fld + ":  </b>"+ value + "<br \>";
							}
							
							idResult.icon = widgetIcon;
							idResult.title = identifyResult.layerName;
							idResult.content = content;
							if(identifyGeom is MapPoint){
								idResult.point = identifyGeom as MapPoint
							}else{
								idResult.point = (returnGeomForZoom) ? getGeomCenter(identifyResult.feature.geometry) : getGeomCenter(identifyGeom);
							}
							idResult.geometry = (returnGeomForZoom) ? identifyResult.feature.geometry : identifyGeom;
							idResult.zoomScale = identZoom;
							idResult.zoom2msg = zoom2Msg;
							
							var iGra2:Graphic = new Graphic(identifyResult.feature.geometry);
							switch (identifyResult.feature.geometry.type){
								case Geometry.MAPPOINT:{
									iGra2.symbol = identMarkerSymbol;
									break;
								}
								case Geometry.POLYLINE:{
									iGra2.symbol = identLineSymbol;
									break;
								}
								case Geometry.POLYGON:
								case Geometry.EXTENT:{
									iGra2.symbol = identFillSymbol;
									break;
								}
							}
							
							idResult.graphic = iGra2;
							idResult.forceScale = identForceScale;
							identifyArrayCollection.addItem(idResult);
							if(enableMoverGra)
								iGra2.addEventListener(MouseEvent.ROLL_OVER, mouseOverGraphic);
							iGra2.attributes = idResult;
							if(returnGeomForZoom)
								graphicsLayer.add(iGra2);
							var popUpInfo2 : PopUpInfo = new PopUpInfo();
							popUpInfo2.title = "{title}";
							popUpInfo2.description = "{content}";
							var infoWindowRenderer2:ClassFactory = new ClassFactory(PopUpRenderer);
							infoWindowRenderer2.properties = { popUpInfo: popUpInfo2};
							iGra2.infoWindowRenderer = infoWindowRenderer2;
						}
					}
				}
				clearMessage();
			}
			
			//on fault
			private function onFault(event:FaultEvent):void
			{
				if(event.fault.faultDetail != "Identify operation not supported on this service")             
					showMessage(event.fault.faultDetail, false);
				else
					showMessage("No Results", false); 
			}
			
			//mouse over graphic
			private function mouseOverGraphic(event:MouseEvent):void
			{
				var gra:Graphic = event.currentTarget as Graphic;
				var idResult:IdResult = gra.attributes as IdResult;
				clearTimeout(hitimer);
				if (map.extent.containsXY(idResult.point.x, idResult.point.y))
					hitimer = setTimeout(showHighlight, 300, [idResult]);
				else
					hideInfoWindow();
			}
			
			private function clear():void
			{
				showStateIdentify();
				hideInfoWindow();
				graphicsLayer.clear();
				clearMessage();
				if(identifyArrayCollection)
					identifyArrayCollection.removeAll()
			}			
			
			
			private var hitimer:uint;
			
			private function mouseOverRecord(event:Event):void
			{
				/* var idResult:IdResult = ItemRenderer(event.target).data as IdResult;
				clearTimeout(hitimer);
				if (map.extent.containsXY(idResult.point.x, idResult.point.y))
					if(enableMoverRec)
						hitimer = setTimeout(showHighlight, 300, [idResult]);
				else
					hideInfoWindow(); */
			}
			
			private function mouseOutRecord(event:Event):void
			{
				//hideInfoWindow();
				//clearSelectedGrapics(null);
			}
			
			private function clearSelectedGrapics(evt:Event):void
			{
				for (var i:int = 0; i < graphicsLayer.numGraphics; ){
					if (Graphic(graphicsLayer.getChildAt(i)).name == "Selected"){
						graphicsLayer.remove(Graphic(graphicsLayer.getChildAt(i)));
						break;
					}else{
						i++;
					}
				}
			}
			
			private function clickRecord(event:Event):void
			{
				var idResult:IdResult = ItemRenderer(event.target).data as IdResult;
				if(idResult.geometry.type == Geometry.MAPPOINT){
					/* if(idResult.forceScale.valueOf() == true){
						map.scale = idResult.zoomScale;
					}else{
						if (map.scale > idResult.zoomScale)
							map.scale = idResult.zoomScale+1;
					} */
					map.level = 8;
					map.centerAt(idResult.point as MapPoint);
				}else{
					if (returnGeomForZoom) {
						map.extent = idResult.geometry.extent.expand(1.2);
					}else{
						/* if(idResult.forceScale.valueOf() == true){
							map.scale = idResult.zoomScale;
						}else{
							if (map.scale > idResult.zoomScale)
								map.scale = idResult.zoomScale+1;
						} */
						map.level = 8;
						map.centerAt(idResult.point as MapPoint);
					}
				}
				hideInfoWindow();
				//showHighlight([idResult]);
			}			
			
			private function showHighlight(params:Array):void
			{
				var showHighlightPoint:MapPoint = params[0].point as MapPoint;
				popUpRenderer.popUpInfo = configurePopUpInfo(params[0].graphic.attributes.links);
				popUpRenderer.graphic = params[0].graphic;
				popUpRenderer.setStyle("skinClass", Class(widgets.Identify.PopUpRendererSkin));
				map.infoWindow.content = popUpRenderer;
				map.infoWindow.contentOwner = popUpRenderer.graphic;
				
				map.infoWindow.addEventListener(Event.CLOSE, clearSelectedGrapics);
				clearSelectedGrapics(null);
				
				if(params[0].point !== params[0].geometry){
					var sGra:Graphic = new Graphic(params[0].geometry);
					switch (params[0].geometry.type){
						case Geometry.MAPPOINT:{
							sGra.symbol = identPicSymbol;
							break;
						}
						case Geometry.POLYLINE:{
							sGra.symbol = identLineSymbol;
							break;
						}
						case Geometry.POLYGON:
						case Geometry.EXTENT:{
							sGra.symbol = identFillSymbol;
							break;
						}
					}
					sGra.name = "Selected";
					graphicsLayer.add(sGra);
					map.infoWindow.show(showHighlightPoint);
				}else{
					var sGra2:Graphic = new Graphic(params[0].point, identPicSymbol, null);
					sGra2.name = "Selected";
					graphicsLayer.add(sGra2);
					map.infoWindow.show(showHighlightPoint);
				}
			}
			
			private function configurePopUpInfo(links:Array):PopUpInfo
			{
				var popUpInfo:PopUpInfo = new PopUpInfo;
				
				popUpInfo.title = "{title}";
				popUpInfo.description = "{content}";
				var pminfos:Array = [];
				
				for(var l:int=0; l<links.length; l++){
					/* if (links[l].link){
						var pos:Number = links[l].link.length - 4;
						var sfx:String = String(links[l].link).substr(pos, 4).toLowerCase();
						if ((sfx == ".jpg") || (sfx == ".png") || (sfx == ".gif")){ // use PopUpMediaInfo if it is an image
							var popUpMediaInfo:PopUpMediaInfo = new PopUpMediaInfo;
							popUpMediaInfo.type = PopUpMediaInfo.IMAGE;
							popUpMediaInfo.imageLinkURL = links[l].link;
							popUpMediaInfo.imageSourceURL = links[l].link;
							pminfos.push(popUpMediaInfo);
						}else{
							var lText:String = (links[l].alias != "") ? links[l].alias : links[l].link;
							popUpInfo.description += "<br /><a href='" + links[l].link + "'>" + lText + "</a>"
						}
					} */
				}
				popUpInfo.popUpMediaInfos = pminfos;
				return popUpInfo;
			}			
			
			private function showMessage(msg:String, swfVisible:Boolean):void
			{
				txtMessage.text = msg;
				swfMessage.visible = swfVisible;
				msgVisible = true;
			}			
			
			private function clearMessage():void
			{
				msgVisible = false;
				if(identifyArrayCollection)
				{
					if(identifyArrayCollection.length<1){
						results.text = "No Layers Selected";
					}
					else{
						results.text = "Results:"+identifyArrayCollection.length;
					}
				}
			}
			
			private function widgetClosedHandler(event:Event):void
			{
				clear();
				setMapAction(null, null, null, null);
				graphicsLayer.visible = false;
				hideInfoWindow();
				setMapNavigation(null, null);
				
				if (selectedDrawingIcon)
					selectedDrawingIcon = null;
			}
			
			private function widgetMinimizedHandler(event:Event):void
			{
				if(graphicsLayer)
					graphicsLayer.visible = false;
			}
			
			private function widgetOpenedHandler(event:Event):void
			{
				if(graphicsLayer)
					graphicsLayer.visible = true;
				
				if (autoActivatedTool != "" )
					activateIdentifyTool(null, autoActivatedTool);
			}
			
			private function showStateIdentify():void
			{
				currentState = "StateIdentify";
				wTemplate.selectedTitlebarButtonIndex = 0;
			}				
			
			private function showStateResults():void
			{
				currentState = "resultsList";
				wTemplate.selectedTitlebarButtonIndex = 1;
			}
			
			private function hideInfoWindow():void
			{
				if (map.infoWindow.contentOwner &&
				((map.infoWindow.contentOwner is Graphic && 
				Graphic(map.infoWindow.contentOwner).graphicsLayer === graphicsLayer) || 
				map.infoWindow.contentOwner is Map)){
					map.infoWindow.hide();
				}
			}
			
			private function sharedDataUpdated(event:AppEvent):void
			{
				var data:Object = event.data;
				if (data.key == "Deactivate_DrawTool"){
					setMapAction(null, null, null, null);
					if (selectedDrawingIcon){
						selectedDrawingIcon.filters = [];
						selectedDrawingIcon = null;
					}
				}
			}
			
			private function geometryService_faultHandler(event:FaultEvent):void
			{
				Alert.show(event.fault.toString(), wTemplate.widgetTitle);
			}
			
			private function iconRollOverHandler(event:MouseEvent):void
			{
				clearSelectionFilter();
				event.target.filters = [ glowFilter ];
			}
			
			private function iconRollOutHandler(event:MouseEvent):void
			{
				clearSelectionFilter();
			}
			
			private function clearSelectionFilter():void
			{
				for (var i:int = 0; i < imageGroup.numChildren; i++){
					if (imageGroup.getChildAt(i).filters && imageGroup.getChildAt(i).filters.length > 0)
						if (!(selectedDrawingIcon && imageGroup.getChildAt(i) === selectedDrawingIcon))
							imageGroup.getChildAt(i).filters = [];
				}
			}
		]]>
	</fx:Script>
	<viewer:WidgetTemplate id="wTemplate"
		closed="widgetClosedHandler(event)"
		open="widgetOpenedHandler(event)"
	    minimized="widgetMinimizedHandler(event)"
		height="290" width="370">
		<s:Group id="StateIdentify" height="100%" width="100%" visible="false" visible.StateIdentify="true">
			<s:layout>
				<s:VerticalLayout gap="6" horizontalAlign="center"/>
			</s:layout>
			<s:Label id="txtLabel"
					 width="100%"
					 text="{descriptionLabel}"
					 textAlign="center"/>
			<s:HGroup id="imageGroup"
					  width="100%"
					  gap="10"
					  horizontalAlign="center">
				<mx:Image id="iDrawPnt"
						  name="{DrawTool.MAPPOINT}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateIdentifyTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_point.png"
						  toolTip="{pointLabel}"
						  useHandCursor="true"/>
				<mx:Image id="iDrawLine"
						  name="{DrawTool.POLYLINE}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateIdentifyTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_line.png"
						  toolTip="{lineLabel}"
						  useHandCursor="true"
						  visible="{enableLine}"
						  includeInLayout="{enableLine}"/>
				<mx:Image id="iDrawExt"
						  name="{DrawTool.EXTENT}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateIdentifyTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_rect.png"
						  toolTip="{rectLabel}"
						  useHandCursor="true"
						  visible="{enableExtent}"
						  includeInLayout="{enableExtent}"/>
				<!--<mx:Image id="iDrawPoly"
						  name="{DrawTool.POLYGON}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateIdentifyTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_poly.png"
						  toolTip="{polyLabel}"
						  useHandCursor="true"
						  visible="{enablePoly}"
						  includeInLayout="{enablePoly}"/>-->
			</s:HGroup>
			<s:HGroup width="100%"
					  horizontalAlign="right"
					  paddingRight="10"
					  paddingTop="2">
				<s:Label buttonMode="true"
						 click="clear()"
						 fontWeight="bold"
						 text="{clearLabel}"
						 textDecoration="underline"/>
			</s:HGroup>
		</s:Group>
		<s:Group id="resultsList" height="100%" width="100%"  visible.resultsList="true" visible="false">
			<s:layout>
				<s:VerticalLayout gap="1"/>
			</s:layout>
			<s:HGroup id="boxMessage"
					  includeInLayout="{msgVisible}"
					  visible="{msgVisible}"
					  width="100%">
				<mx:SWFLoader id="swfMessage"
							  source="assets/images/loader.swf"
							  visible="false"/>
				<s:Label id="txtMessage"
						 text="{idResultDG.dataProvider.length > 0}"
						 width="90%"/>
			</s:HGroup>
			<s:HGroup width="100%"
					  horizontalAlign="right"
					  paddingRight="10"
					  paddingTop="2"
					  includeInLayout="{idResultDG.dataProvider.length > 0}"
					  visible="{idResultDG.dataProvider.length > 0}">
				<s:Label buttonMode="true"
						 click="clear()"
						 fontWeight="bold"
						 text="{clearLabel}"
						 textDecoration="underline"/>
			</s:HGroup>
			<s:Label id="results" text="Results"/>
			<s:Scroller height="100%" width="100%">
				<Ident:IdResultDataGroup id="idResultDG"
											  dataProvider="{identifyArrayCollection}"
											  idResultClick="clickRecord(event)"
											  idResultOver="mouseOverRecord(event)"
											  idResultOut="mouseOutRecord(event)">
					<Ident:layout>
						<s:VerticalLayout gap="2"
										  horizontalAlign="justify"
										  useVirtualLayout="true"/>
					</Ident:layout>
				</Ident:IdResultDataGroup>
			</s:Scroller>
		</s:Group>
	</viewer:WidgetTemplate>
</viewer:BaseWidget>