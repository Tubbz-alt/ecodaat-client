<?xml version="1.0" encoding="utf-8"?>
<viewer:BaseWidget xmlns:esri			="http://www.esri.com/2008/ags"
				   xmlns:fx				="http://ns.adobe.com/mxml/2009"
				   xmlns:s				="library://ns.adobe.com/flex/spark"
				   xmlns:mx				="library://ns.adobe.com/flex/mx"
				   xmlns:mxeffects     	="com.adobe.ac.mxeffects.*"
				   xmlns:viewer        	="com.esri.viewer.*"
				   xmlns:Search       	="widgets.eSearch.*"
				   xmlns:dg      	="widgets.eSearch.DataGridCheck*"
				   xmlns:supportClasses ="com.esri.ags.tasks.supportClasses.*"
				   currentState			="textInput"
				   widgetConfigLoaded	="init()" xmlns:DataGridCheck="widgets.eSearch.DataGridCheck.*" xmlns:MultiDropDown="com.esri.viewer.skins.MultiDropDown.*" xmlns:acm="com.acm.*"  >
	<viewer:states>
		<s:State name="graphicalInput"/>
		<s:State name="textInput"/>
		<s:State name="timeInput"/>
		<s:State name="fieldInput"/>
		<s:State name="resultsList"/>
	</viewer:states>
	<viewer:transitions>
		<s:Transition autoReverse="true" toState="*">
			<s:Fade targets="{[graphicalInput, textInput, timeInput,fieldInput,resultsList]}"/>
		</s:Transition>
	</viewer:transitions>	
	<fx:Declarations>
		<esri:SimpleMarkerSymbol id="selectedPoint" color="0x5F9E61" outline="{outlineColor}" />
		<esri:SimpleLineSymbol color="0x9C9797" id="outlineColor"/>
		<s:GlowFilter id="glowFilter"
					  alpha="1"
					  color="{getStyle('focusColor')}"
					  inner="true"
					  strength="2"/>
		<esri:GeometryService id="geometryService"
							  fault="geometryService_faultHandler(event)"
							  url="http://tasks.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer"/>
		<s:ColorMatrixFilter id="cOver" matrix="[0.5,0.5,0.5,0,0,0.5,0.5,0.5,0,0,0.5,0.5,0.5,0,0,0,0,0,0.6,0]"/>
		<supportClasses:RelationshipQuery id="relatesQuery" outFields="[*]"/>
		<!--<mx:DateFormatter id="iDateFormat" />-->
		<esri:FlareSymbol id="flareSymbol" 
						  backgroundAlphas="[0.5,1.0]"
						  backgroundColors="[0x1A9850,0x66BD63,0xA6D96A,0xD9EF8B,0xFEE08B,0xFDAE61,0xF46D43,0xD73027]"
						  flareMaxCount="40" 
						  flareSizeIncOnRollOver="3"
						  sizes="[15,20,25,30,35,40,45,50]"  
						  weights="[20,200,420,720,920,1120,2200,10000]"/>
		<esri:WeightedClusterer   id="clusterer" symbol="{flareSymbol}">
			<esri:center>
				<esri:MapPoint x="{(-14477000-6677000)*0.5}" y="{(2273000+8399000)*0.5}"/>
			</esri:center>
		</esri:WeightedClusterer>
		
		<mx:ArrayCollection id="fieldsArray">
			<mx:source>
				<fx:Array>
					<fx:Object gridfield="true" sortnumber="-1" alias="Layer Options" />
				</fx:Array>
			</mx:source>
		</mx:ArrayCollection>
		<mx:ArrayCollection id="fieldsArray2">
			<mx:source>
				<fx:Array>
					<fx:Object gridfield="true" sortnumber="0" alias="Layer Options" />
				</fx:Array>
			</mx:source>
		</mx:ArrayCollection>		
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
			import com.esri.ags.FeatureSet;
			import com.esri.ags.Graphic;
			import com.esri.ags.Map;
			import com.esri.ags.SpatialReference;
			import com.esri.ags.clusterers.supportClasses.FlareSymbol;
			import com.esri.ags.events.DrawEvent;
			import com.esri.ags.events.FlareMouseEvent;
			import com.esri.ags.events.GeometryServiceEvent;
			import com.esri.ags.events.GeoprocessorEvent;
			import com.esri.ags.events.GraphicEvent;
			import com.esri.ags.events.GraphicsLayerEvent;
			import com.esri.ags.events.LayerEvent;
			import com.esri.ags.events.MapEvent;
			import com.esri.ags.geometry.Extent;
			import com.esri.ags.geometry.Geometry;
			import com.esri.ags.geometry.MapPoint;
			import com.esri.ags.geometry.Multipoint;
			import com.esri.ags.geometry.Polygon;
			import com.esri.ags.geometry.Polyline;
			import com.esri.ags.layers.ArcGISDynamicMapServiceLayer;
			import com.esri.ags.layers.FeatureLayer;
			import com.esri.ags.layers.GraphicsLayer;
			import com.esri.ags.layers.Layer;
			import com.esri.ags.layers.supportClasses.CodedValue;
			import com.esri.ags.layers.supportClasses.CodedValueDomain;
			import com.esri.ags.layers.supportClasses.FeatureType;
			import com.esri.ags.layers.supportClasses.Field;
			import com.esri.ags.layers.supportClasses.LayerDetails;
			import com.esri.ags.layers.supportClasses.RangeDomain;
			import com.esri.ags.layers.supportClasses.TableDetails;
			import com.esri.ags.portal.PopUpRenderer;
			import com.esri.ags.portal.supportClasses.PopUpInfo;
			import com.esri.ags.symbols.PictureMarkerSymbol;
			import com.esri.ags.symbols.SimpleFillSymbol;
			import com.esri.ags.symbols.SimpleLineSymbol;
			import com.esri.ags.symbols.SimpleMarkerSymbol;
			import com.esri.ags.symbols.Symbol;
			import com.esri.ags.symbols.TextSymbol;
			import com.esri.ags.tasks.GeometryService;
			import com.esri.ags.tasks.GeometryServiceSingleton;
			import com.esri.ags.tasks.Geoprocessor;
			import com.esri.ags.tasks.QueryTask;
			import com.esri.ags.tasks.supportClasses.BufferParameters;
			//import com.esri.ags.tasks.supportClasses.ParameterValue;
			import com.esri.ags.tasks.supportClasses.Query;
			import com.esri.ags.tools.DrawTool;
			import com.esri.ags.utils.GeometryUtil;
			import com.esri.ags.utils.GraphicUtil;
			import com.esri.ags.utils.WebMercatorUtil;
			import com.esri.viewer.AppEvent;
			import com.esri.viewer.components.TitlebarButton;
			import com.esri.viewer.components.toc.utils.MapUtil;
			
			import flash.utils.clearTimeout;
			import flash.utils.setTimeout;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.controls.ToolTip;
			import mx.events.CloseEvent;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			import mx.events.ValidationResultEvent;
			import mx.formatters.CurrencyFormatter;
			import mx.formatters.DateFormatter;
			import mx.formatters.NumberFormatter;
			import mx.managers.ToolTipManager;
			import mx.rpc.AsyncResponder;
			import mx.rpc.Fault;
			import mx.rpc.events.FaultEvent;
			import mx.utils.ObjectUtil;
			import mx.utils.StringUtil;
			import mx.validators.NumberValidator;
			
			import spark.collections.Sort;
			import spark.collections.SortField;
			import spark.components.supportClasses.ItemRenderer;
			
			import widgets.Identify.PopUpRendererSkin;
			//import widgets.eSearch.skins.PopUpRendererSkin;
						
			//labels
			[Bindable]
			private var lblbufferUserGraphic:String;
			[Bindable]
			private var noRelatesFound:String;
			[Bindable]
			private var noRelatesFoundAlertTitle:String;
			private var graphicalsearchLabel:String;
			private var textsearchLabel:String;
			private var resultsLabel:String;
			private var gridresultsLabel:String;
			[Bindable]
			private var enableMultiPartSearch:String;
			[Bindable]
			private var lblTolerance:String;
			[Bindable]
			private var layerLabel:String;
			[Bindable]
			private var sampleType:String = "";
			[Bindable]
			private var layerExprLabel:String;
			private var nolayerLabel:String;
			[Bindable]	
			private var submitLabel:String;	
			[Bindable]
			private var pointLabel:String;
			[Bindable]
			private var bufferAlphaLabel:String;
			[Bindable]
			private var bufferColorLabel:String;
			[Bindable]
			private var lineLabel:String;
			[Bindable]
			private var rectangleLabel:String;
			[Bindable]
			private var polygonLabel:String;
			[Bindable]
			private var clearLabel:String;
			[Bindable]
			private var zoomallLabel:String;
			[Bindable]
			private var zoomallTip:String;
			private var loadingLabel:String;	
			private var selectionLabel:String;		
			[Bindable]
			private var drawGraLabel:String;
			[Bindable]
			private var bufferGraLabel:String;
			[Bindable]
			private var msgVisible:Boolean = false;
			[Bindable]
			private var searchLayerLabel:String;
			[Bindable]
			private var relatLayerWhereLabel:String;
			[Bindable]
			private var bufferLabel:String;
			[Bindable]
			private var drawGraphicsLayer:GraphicsLayer;
			[Bindable]
			private var bufferGraphicsLayer:GraphicsLayer;
			[Bindable]
			private var typeQ:String = "table";
			[Bindable]
			private var trawl_fields:String;
			[Bindable]
			private var ich_fields:String;
			[Bindable]
			private var zoop_fields:String;
			[Bindable]
			private var trawl_fieldsL:String;
			[Bindable]
			private var ich_fieldsL:String;
			[Bindable]
			private var zoop_fieldsL:String;
			
			//set to show multiple search option
			[Bindable]
			private var multipleSearch:Boolean = true;
			[Bindable]
			private var sampleSearch:Boolean = true;
			[Bindable]
			private var haulSearch:Boolean = false;
			[Bindable]
			private var spatLayer:Boolean = true;
			[Bindable]
			private var microZoopVisible:Boolean = false;
			[Bindable]
			private var optionAttribute:Boolean = false;
			[Bindable]
			private var trawlOptions:Boolean = false;
			[Bindable]
			private var ichOptions:Boolean = false;
			[Bindable]
			private var bobOptions:Boolean = false;
			[Bindable]
			private var associationOptions:Boolean = false;
			[Bindable]
			private var hideotherOptions:Boolean = false;			
			[Bindable]
			private var yearArray:ArrayCollection = new ArrayCollection;
			[Bindable]
			private var dayArray:ArrayCollection = new ArrayCollection([{gridfield:'true', alias:'1-14'},{gridfield:'true', alias:'15-31'}]);
			
			[Bindable]
			private var monthArray:ArrayCollection = new ArrayCollection([{gridfield:'true', alias:'January',data:'1'}
				,{gridfield:'true', alias:'February',data:'2'}
				,{gridfield:'true', alias:'March',data:'3'}
				,{gridfield:'true', alias:'April',data:'4'}
				,{gridfield:'true', alias:'May',data:'5'}
				,{gridfield:'true', alias:'June',data:'6'}
				,{gridfield:'true', alias:'July',data:'7'}
				,{gridfield:'true', alias:'August',data:'8'}
				,{gridfield:'true', alias:'September',data:'9'}
				,{gridfield:'true', alias:'October',data:'10'}
				,{gridfield:'true', alias:'November',data:'11'}
				,{gridfield:'true', alias:'December',data:'12'}]);
			
			[Bindable]
			private var speciesIchArray:ArrayCollection;
			[Bindable]
			private var geo_locArray:ArrayCollection;
			[Bindable]
			private var speciesTrawlArray:ArrayCollection;
			[Bindable]
			private var cruiseArray:ArrayCollection;
			[Bindable]
			private var cruiseArray_seacat:ArrayCollection;
			[Bindable]
			private var cruiseArray_chlor:ArrayCollection;
			[Bindable]
			private var cruiseArray_ctdb:ArrayCollection;
			[Bindable]
			private var cruiseArray_nutr:ArrayCollection;
			[Bindable]
			private var gearnamesArray:ArrayCollection;
			[Bindable]
			private var taxonArray:ArrayCollection;
			//Properties
			private var relateIcon:String;
			private var relateToolTip:String;
			[Bindable]
			private var eDrawEnabled:Boolean = false;
			[Bindable]
			private var pBufferEnabled:Boolean = false;
			[Bindable]
			private var applyBufferLabel:String;
			private var resultsFeatureSet:FeatureSet;
			private var zoomScale:Number = 5000;
			private var zoomPercent:Number = 1.2;
			private var configSearchGraphical:Array;
			private var configSearchText:Array;
			private var configDomainVals:Array;
			private var configUserVals:Array;
			private var queryLayerRels:Array;
			private var queryLayer:FeatureLayer;
			private var relqueryLayer:FeatureLayer;
			private var queryGeom:Geometry;
			private var queryExpr:String;
			private var queryFields:XMLList;
			private var gridFields:Array = [];
			private var gridHyperFields:Array = [];
			private var relateFields:Array = [];
			private var qrelateFields:Array = [];
			private var relateHyperFields:Array = [];
			private var queryTitleField:String;
			private var qLinks:Array = [];
			private var lyrQLinks:Array = [];
			private var queryDefExpr:String = "";
			private var queryLinkIconIsField:Boolean;
			private var queryEnableExport:Boolean;
			private var timer:Timer;
			private const ICON_URL:String = "assets/images/";
			private var WIDGET_URL:String = "widgets/eSearch/assets/images/";
			private var gridDataProvider:Object;
			private var wFields:ArrayCollection;
			private var sWidget:SearchWidget;
			private var _csvName:String;
			private var relatescsvName:String;
			private var fldAliases:Object;
			private var relfldAliases:Object;
			private var queryMultiImgField:String;
			private var graphicsLayerBuffer:GraphicsLayer;
			private var configSpatialSearchLayers:Array;
			private var configSpatialSearchRelation:Array;
			private var configLayerExprs:Array;
			private var configTableExprs:Array;
			private var configLayerRels:Array;
			private var configTableRels:Array;
			private var configBufferUnits:Array;
			private var spatialsearchLabel:String;
			private var geomArr:Array;
			private var csvSep:String;
			private var expBtnLbl:String;
			private var exp2csvOptLbl:String;
			private var exp2txtOptLbl:String;
			private var queryExprForSpatRel:Boolean;
			private var sReff:SpatialReference;
			private var disableButtons:String;
			private var defaultSelectionOption:String;
			private var qLayer:FeatureLayer;
			private var layerDetails:*;
			private var myTip:ToolTip;
			private var selectedDrawingIcon:Image;
			private var lState:String = "textInput";
			private var lblSum:String;
			private var sumField:String;
			private var pointSearchTolerance:Number = 6;
			private var popUpRenderer:PopUpRenderer = new PopUpRenderer();
			private var openDataGrid:Boolean;
			private var lastTool:String;
			
			[Bindable] private var graGraphicsLayer:GraphicsLayer;
			
			private var selectedGraphicalTool:String;
			[Bindable] private var multiPartGraphicSearch:Boolean;
			[Bindable] private var applyTolleranceByDefault:Boolean;
			[Bindable] private var widgetAndGridIteract:Boolean;
			
			private var executingURLquery:Boolean;
			
			private var floatorfixed:String;
			
			private var disRelatesInFixed:Boolean;
			
			private var numberValidator:NumberValidator;
			
			private var rWindow:RelatesWindow;
			
			[Bindable]
			private var searchResultAC:ArrayCollection;
			//Formatters
			[Bindable]
			private var graphicsLayer:GraphicsLayer;
			private var dateFormatter:DateFormatter = new DateFormatter();
			private var numFormatter:NumberFormatter = new NumberFormatter();
			private var currFormatter:CurrencyFormatter = new CurrencyFormatter();
			
			//Symbols
			private var drawSymbol:Symbol;
			private var resultMarkerSymbol:Symbol;
			private var resultLineSymbol:Symbol;
			private var resultFillSymbol:Symbol;
			private var resultSATSymbol:Symbol;
			private var overFillSymbol:Symbol;
			
			//tools - geoprocessing
			private var ichlengthGP:String;
			private var trawllengthGP:String;
			private var ichabundanceGP:String;
			private var catchzerotoolGP:String;
			private var catchzerotoolGPbob:String;
			
			[Embed(source="assets/images/i_about.png")]
			private var iconClass:Class;
			[Embed(source="widgets/eSearch/assets/images/i_relate.png")]
			private var relateClass:Class;
			[Embed(source="assets/images/i_table.png")]
			private var satClass:Class;
			[Bindable]
			private var tokenUse:String = "";
			private var fieldResultMain:ArrayCollection;
			
			private function init():void
			{					
				sWidget = this;
				WIDGET_URL = config.substring(0,config.lastIndexOf("/")) + "/assets/images/";
				if (configXML){
					if (GeometryServiceSingleton.instance.url){
						geometryService.url = GeometryServiceSingleton.instance.url;
						geometryService.token = GeometryServiceSingleton.instance.token;
						geometryService.proxyURL = GeometryServiceSingleton.instance.proxyURL;
					}
					relateIcon = configXML.relateicon || WIDGET_URL + "i_relate.png";
					//labels
					tokenUse = configXML.token;
					lblbufferUserGraphic = configXML.labels.bufferusergraphics || "Buffer Graphic";
					noRelatesFound = configXML.labels.norelatesfound || "No related features found";
					noRelatesFoundAlertTitle = configXML.labels.norelatesfoundalerttitle || "No Results";
					bufferColorLabel = configXML.labels.buffercolor || "Select buffer color";
					bufferAlphaLabel = configXML.labels.bufferalpha || "Adjust buffer alpha"
					lblTolerance = configXML.labels.addtolerance || "Add search tolerance to point selection";
					drawGraLabel = configXML.labels.existingdrawgraphicslabel || "Use Existing Draw Widget Graphics";
					bufferGraLabel = configXML.labels.existingbuffergraphicslabel || "Use Existing Point Buffer Widget Graphics";
					graphicalsearchLabel = configXML.labels.graphicalsearchlabel || "Graphical Search";
					textsearchLabel = configXML.labels.textsearchlabel || "Text Search";
					resultsLabel = configXML.labels.resultslabel || "Results";
					layerLabel = configXML.labels.layerlabel || "Search Layer:";
					layerExprLabel = configXML.labels.layerfieldlabel || "Search Layer Field:";
					nolayerLabel = configXML.labels.nolayerlabel || "No search layer defined.";
					submitLabel = configXML.labels.submitlabel || "Search";
					pointLabel = configXML.labels.pointlabel || "Select by Point";
					lineLabel = configXML.labels.linelabel || "Select by Line";
					rectangleLabel = configXML.labels.rectanglelabel || "Select by Rectangle";
					polygonLabel = configXML.labels.polygonlabel || "Select by Polygon";
					clearLabel = configXML.labels.clearlabel || "Clear";
					zoomallLabel = configXML.labels.zoomalllabel || "Zoom";
					zoomallTip = configXML.labels.zoomalltip || "Zoom to all results";
					loadingLabel = configXML.labels.loadinglabel || "Loading...";
					selectionLabel = configXML.labels.selectionlabel || "Features Selected:";
					gridresultsLabel = configXML.labels.gridresultslabel || "Show Results in Grid";
					exp2csvOptLbl = configXML.labels.export2csvoptionlabel || "Export to CSV";
					exp2txtOptLbl = configXML.labels.export2txtoptionlabel || "Export to Txt";
					expBtnLbl = configXML.labels.exportbtnlabel || "Export...";
					_csvName = configXML.labels.csvdefaultname || "Selected Records";
					var d_file:Date = new Date();
					_csvName+=d_file.minutes.toString()+"_"+String(d_file.month+1)+"_"+d_file.fullYear.toString();
					
					relatescsvName = configXML.labels.relatescsvdefaultname || "Related Records";
					csvSep = configXML.csvseparator;
					spatialsearchLabel = configXML.labels.spatialsearchlabel || "Spatial search";
					searchLayerLabel = configXML.labels.searchlayerlabel || "Search entities of:";
					bufferLabel = configXML.labels.bufferlabel || "apply a search distance:";
					applyBufferLabel = configXML.labels.applybufferlabel || "Apply buffer";
					relateToolTip = configXML.relatetooltip || "Show Relates";
					sReff = new SpatialReference(configXML.spatialreference);
					defaultSelectionOption = configXML.defaultselectionoption || "textInput";
					currentState = defaultSelectionOption;
					disableButtons = configXML.disablebuttons || "";
					selectedGraphicalTool = configXML.selectedgraphicaltool || "";
					enableMultiPartSearch = configXML.labels.enablemultipartsearch || "enable multi-part graphics";
					applyTolleranceByDefault = configXML.tolerancebydefault && configXML.tolerancebydefault == "true";
					widgetAndGridIteract = configXML.enabledatagridinteractionwithwidget && configXML.enabledatagridinteractionwithwidget == "true";
					
					trawl_fields = configXML.trawlfields;
					ich_fields = configXML.ichfields;
					zoop_fields = configXML.zoopfields;
					trawl_fieldsL = configXML.trawlfieldsList;
					ich_fieldsL = configXML.ichfieldsList;
					zoop_fieldsL = configXML.zoopfieldsList;
					
					ichlengthGP = configXML.datatools.ichlength;
					trawllengthGP = configXML.datatools.trawllength;
					ichabundanceGP = configXML.datatools.ichabundance;
					catchzerotoolGP = configXML.datatools.catchzero;
					catchzerotoolGPbob = configXML.datatools.catchzeroBob;
					
					configSpatialSearchRelation = [];
					var operList:XMLList = configXML..spatialrelationship;
					var sOpBtn:Image;
					for (var s:Number = 0; s < operList.length(); s++){
						var srName:String = operList[s].name;
						var srLabel:String = operList[s].label;
						var spatialRelationship:Object =
						{
							name: srName,
							label: srLabel
						};
						sOpBtn = new Image();
						sOpBtn.name = srName;
						sOpBtn.source = getSopImg(srName);
						sOpBtn.toolTip = srLabel;
						//sOpBtn.addEventListener(MouseEvent.CLICK, sOpBtnClickHandler);
						sOpBtn.useHandCursor = true;
						sOpBtn.buttonMode = true;
						configSpatialSearchRelation.push(spatialRelationship);
					}
					
					eDrawEnabled = configXML.enabledrawgraphicbutton && configXML.enabledrawgraphicbutton == "true";
					pBufferEnabled = configXML.enablebuffergraphicbutton && configXML.enablebuffergraphicbutton == "true";
					multiPartGraphicSearch = configXML.multipartgraphicsearch && configXML.multipartgraphicsearch == "true";
					(multiPartGraphicSearch.valueOf() == true) ? graFeatureQueryBtn.visible = true : graFeatureQueryBtn.visible = false;
					floatorfixed = configXML.floatorfixed || "float";
					disRelatesInFixed = configXML.floatorfixed.@disablerelatestabinfixed && configXML.floatorfixed.@disablerelatestabinfixed == "true";
					
					if(eDrawEnabled){
						eDrawBtn.filters = [cOver];
						eDrawBtn.buttonMode = eDrawBtn.useHandCursor = eDrawBtn.enabled = false;
						map.addEventListener(MapEvent.LAYER_ADD, checkForeDrawGL);					
						MapUtil.forEachMapLayer(map, function(layer:Layer):void
						{
							if(layer.name.toLowerCase() == "draw features"){
								drawGraphicsLayer = layer as GraphicsLayer;
								if(drawGraphicsLayer.numGraphics > 0)
									checkeDrawNumGras(null);
								drawGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_ADD, checkeDrawNumGras);
								drawGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_REMOVE, checkeDrawNumGras);
								drawGraphicsLayer.addEventListener(GraphicsLayerEvent.GRAPHICS_CLEAR, checkeDrawNumGras);
							}
						});
					}
					
					if(pBufferEnabled){
						pBufferBtn.filters = [cOver];
						pBufferBtn.buttonMode = pBufferBtn.useHandCursor = pBufferBtn.enabled = false;
						map.addEventListener(MapEvent.LAYER_ADD, checkForpntBufferGL);					
						MapUtil.forEachMapLayer(map, function(layer:Layer):void
						{
							if(layer.name.toLowerCase() == "buffer results"){
								bufferGraphicsLayer = layer as GraphicsLayer;
								if(bufferGraphicsLayer.numGraphics > 0)
									checkBufferNumGras(null);
								bufferGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_ADD, checkBufferNumGras);
								bufferGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_REMOVE, checkBufferNumGras);
								bufferGraphicsLayer.addEventListener(GraphicsLayerEvent.GRAPHICS_CLEAR, checkBufferNumGras);
							}
						});
					}
					
					configBufferUnits = [];
					var bufferUnitsList:XMLList = configXML..bufferunit;
					for (var b:int = 0; b < bufferUnitsList.length(); b++){
						var buffUnitName:String = bufferUnitsList[b].name;
						var buffUnitLabel:String = bufferUnitsList[b].label;
						var bufferUnit:Object =
						{
							name: buffUnitName,
							label: buffUnitLabel
						};
						configBufferUnits.push(bufferUnit);
					}
					cboGraBufferUnit.dataProvider = configBufferUnits;
										
					configSearchGraphical = [];
					configSearchText = [];
					configSpatialSearchLayers = [];
					configDomainVals = [];
					var r:Number;
					var i:Number;
					var j:Number;
					var l:Number;
					var lyrList:XMLList = configXML..layer;
					for (i = 0; i < lyrList.length(); i++){
						configLayerExprs = [];
						configLayerRels = [];
						var lyrURL:String = lyrList[i].url;
						var lyrToken:String = lyrList[i].token;
						var lyrLabel:String = lyrList[i].name;
						var lyrGraphicalLabel:String = lyrList[i].graphicalsearchlabel;
						var lyrRelList:XMLList = configXML.layers.layer[i]..relate;
						for (r = 0; r < lyrRelList.length(); r++){
							var lyrRelLabel:String = lyrRelList[r].@label;
							var lyrRelId:String = lyrRelList[r].@id;
							var lyrRelIcon:String = lyrRelList[r].@icon || "widgets/eSearch/assets/images/i_relate.png";
							var lyrRelFields:XMLList = lyrRelList[r].fields;
							var lyrRelEnableExport:Boolean = lyrRelList[r].@enableexport && lyrRelList[r].@enableexport == "true";
							var lyrRel:Object = {
								id: lyrRelId,
								fields: lyrRelFields,
								label: lyrRelLabel,
								enableexport: lyrRelEnableExport,
								icon: lyrRelIcon
							}
							configLayerRels.push(lyrRel);
						}
						var lyrExprList:XMLList = configXML.layers.layer[i]..expression;
						for (j = 0; j < lyrExprList.length(); j++){
							var lyrExprAlias:String = lyrExprList[j].@alias;
							var lyrTextLabel:String = lyrExprList[j].@textsearchlabel;
							var lyrExpr:String = lyrExprList[j];
							var lyrField:String = lyrExprList[j].@field;
							var lyrUserList:String = lyrExprList[j].@userlist;
							var lyrDomain:Boolean = lyrExprList[j].@usedomain && lyrExprList[j].@usedomain == "true";
							var expr:Object ={
								label: lyrExprAlias,
								textlabel: lyrTextLabel,
								expression: lyrExpr,
								field: lyrField,
								usedomain: lyrDomain,
								userlist: lyrUserList
							}
							configLayerExprs.push(expr);
						}
						var lyrDefExpr:String = lyrList[i].definitionexpression;
						var lyrFields:XMLList = lyrList[i].fields;
						var lyrTitleField:String = lyrList[i].titlefield;
						
						var lyrLinks:Array = [];
						var lyrLinkList:XMLList = lyrList[i]..link;
						for (l = 0; l < lyrLinkList.length(); l++){
							var lyrLinkAlias:String = lyrLinkList[l].@alias || "";
							var lyrLinkField:String = lyrLinkList[l].@field || "";
							var lyrLinkPre:String = lyrLinkList[l].linkprefix || "";
							var lyrLinkSuffix:String = lyrLinkList[l].linksuffix || "";
							var lyrLinkIconField:String = lyrLinkList[l].iconfield || "";
							var lyrLinkIconPre:String = lyrLinkList[l].iconprefix || "";
							var lyrLinkIconSuffix:String = lyrLinkList[l].iconsuffix || "";
							var incLinkInRslts:Boolean = lyrLinkList[l].@includeinresults && lyrLinkList[l].@includeinresults == "true";
							var linkObj:Object = {
								field: lyrLinkField,
								pre: lyrLinkPre,
								suf: lyrLinkSuffix,
								inc: incLinkInRslts,
								alias: lyrLinkAlias,
								icon: lyrLinkIconField,
								iconpre: lyrLinkIconPre,
								iconsuf: lyrLinkIconSuffix
							}
							lyrLinks.push(linkObj);
						}
						var lyrEnableExport:Boolean = lyrList[i].enableexport && lyrList[i].enableexport == "true";
						var lyrMultiImgField:String = lyrList[i].multiimagefield;
						var useProxy:Boolean = lyrList[i].useproxy && lyrList[i].useproxy == "true";
						var useAMF:String = lyrList[i].useamf;
						var openDG:Boolean = lyrList[i].autoopendatagrid && lyrList[i].autoopendatagrid == "true";
						if ((lyrList[i].zoomscale.@usegeometry) && (lyrList[i].zoomscale.@usegeometry == "true")){
							zoomScale = Number.NaN;
							if(lyrList[i].zoomscale.@zoompercent){
								zoomPercent = Number(lyrList[i].zoomscale.@zoompercent)
							}else{
								zoomPercent = 1.2
							}
						}else{
							if (Number(lyrList[i].zoomscale) > 0)
								zoomScale = Number(lyrList[i].zoomscale);
						}
						
						var lyrSpatialLabel:String = lyrList[i].spatialquerylabel;
						var lyrSpatialSearchLyr:String = lyrList[i].spatialsearchlayer;
						
						var layer:FeatureLayer = new FeatureLayer(lyrURL);
						
						if(tokenUse !="")
						{
							layer.token = tokenUse;
						}
						
						if (useProxy && configData.proxyUrl)
							layer.proxyURL = configData.proxyUrl;
						if (useAMF)
							layer.useAMF = useAMF == "true";
						if (lyrFields && lyrFields[0].@all[0] == "true"){
							layer.outFields = ["*"];
						}else if (lyrFields){
							var fields:XMLList = lyrFields.field;
							layer.outFields = [];
							for each (var fieldXML:XML in fields){
								if (fieldXML.@name[0])
									layer.outFields.push(fieldXML.@name[0]);
							}
						}
						
						var searchLayer:Object = {
							layer: layer,
							label: lyrLabel,
							titlefield: lyrTitleField,
							spatialsearchlabel: lyrSpatialLabel,
							spatialsearchlayer: lyrSpatialSearchLyr,
							graphicallabel: lyrGraphicalLabel,
							expr: configLayerExprs,
							fields: lyrFields,
							links: lyrLinks,
							multi: lyrMultiImgField,
							zoomscale: zoomScale,
							zoompercent: zoomPercent,
							enableexport: lyrEnableExport,
							defexpr: lyrDefExpr,
							opendg: openDG,
							relates: configLayerRels
						}
						configSearchGraphical.push(searchLayer);
						
						if (searchLayer.spatialsearchlayer == "true")
							configSpatialSearchLayers.push(searchLayer);
						
						if (lyrExpr){
							configSearchText.push(searchLayer);
							if(i==0){
								qLayer = new FeatureLayer(lyrURL);
								if(configLayerExprs[0].usedomain)
									popCBwithDomain(configLayerExprs[0].field);
								else if(configLayerExprs[0].userlist != "")
									popCBwithUserList(configLayerExprs[0].userlist);
							}
						}
					}
					
					//create checklist array of fields
					//do this once
					//for the first layer in the xml config file (currently Specimen)
					//fills both text and graphical attribute checklists
					var layer2:ArcGISDynamicMapServiceLayer= new ArcGISDynamicMapServiceLayer(lyrList[0].url);
					
					if(tokenUse !="")
					{
						layer2.token = tokenUse;
					}
					//get layer attribute lists
					layer2.getDetails(1, new AsyncResponder(myResultFunction, myFaultFunction));
					layer2.getDetails(1, new AsyncResponder(myResultFunctionGraphical, myFaultFunction));
									
//---------------------------TABLES---------------------------------------------------------------------------
					var tblList:XMLList = configXML..table;
					for (i = 0; i < tblList.length(); i++){
						configTableExprs = [];
						configTableRels = [];
						var tblURL:String = tblList[i].url;
						var tblLabel:String = tblList[i].name;
						var tabToken:String = tblList[i].token;
						var tblRelList:XMLList = configXML.tables.table[i]..relate;
						for (r = 0; r < tblRelList.length(); r++){
							var tblRelLabel:String = tblRelList[r].@label;
							var tblRelId:String = tblRelList[r].@id;
							var tblRelIcon:String = tblRelList[r].@icon || "widgets/eSearch/assets/images/i_relate.png";
							var tblRelFields:XMLList = tblRelList[r].fields;
							var tblRelEnableExport:Boolean = tblRelList[r].@enableexport && tblRelList[r].@enableexport == "true";
							var tblRel:Object = {
								id: tblRelId,
								fields: tblRelFields,
								label: tblRelLabel,
								enableexport: tblRelEnableExport,
								icon: tblRelIcon
							}
							configTableRels.push(tblRel);
						}
						var tblExprList:XMLList = configXML.tables.table[i]..expression;
						for (j = 0; j < tblExprList.length(); j++){
							var tblExprAlias:String = tblExprList[j].@alias;
							var tblTextLabel:String = tblExprList[j].@textsearchlabel;
							var tblExpr:String = tblExprList[j];
							var tblField:String = tblExprList[j].@field;
							var tblUserList:String = tblExprList[j].@userlist;
							var tblDomain:Boolean = tblExprList[j].@usedomain && tblExprList[j].@usedomain == "true";
							var tblexpr:Object ={
								label: tblExprAlias,
								textlabel: tblTextLabel,
								expression: tblExpr,
								field: tblField,
								usedomain: tblDomain,
								userlist: tblUserList
							}
							configTableExprs.push(tblexpr);
						}
						var tblDefExpr:String = tblList[i].definitionexpression;
						var tblFields:XMLList = tblList[i].fields;
						var tblTitleField:String = tblList[i].titlefield;
						
						var tblLinks:Array = [];
						var tblLinkList:XMLList = tblList[i]..link;
						for (l = 0; l < tblLinkList.length(); l++){
							var tblLinkAlias:String = tblLinkList[l].@alias || "";
							var tblLinkField:String = tblLinkList[l].@field || "";
							var tblLinkPre:String = tblLinkList[l].linkprefix || "";
							var tblLinkSuffix:String = tblLinkList[l].linksuffix || "";
							var tblLinkIconField:String = tblLinkList[l].iconfield || "";
							var tblLinkIconPre:String = tblLinkList[l].iconprefix || "";
							var tblLinkIconSuffix:String = tblLinkList[l].iconsuffix || "";
							var tblincLinkInRslts:Boolean = tblLinkList[l].@includeinresults && tblLinkList[l].@includeinresults == "true";
							var tbllinkObj:Object = {
								field: tblLinkField,
								pre: tblLinkPre,
								suf: tblLinkSuffix,
								inc: tblincLinkInRslts,
								alias: tblLinkAlias,
								icon: tblLinkIconField,
								iconpre: tblLinkIconPre,
								iconsuf: tblLinkIconSuffix
							}
							tblLinks.push(tbllinkObj);
						}
						var tblEnableExport:Boolean = tblList[i].enableexport && tblList[i].enableexport == "true";
						var tblMultiImgField:String = tblList[i].multiimagefield;
						var tbluseProxy:Boolean = tblList[i].useproxy && tblList[i].useproxy == "true";
						var tbluseAMF:String = tblList[i].useamf;
						var tblopenDG:Boolean = tblList[i].autoopendatagrid && tblList[i].autoopendatagrid == "true";
	
						var table:FeatureLayer = new FeatureLayer(tblURL);
						
						if(tokenUse !="")
						{
							table.token = tokenUse;
						}
						table.useMapTime = false;
						
						if (useProxy && configData.proxyUrl)
							table.proxyURL = configData.proxyUrl;
						if (useAMF)
							table.useAMF = useAMF == "true";
						if (tblFields && tblFields[0].@all[0] == "true"){
							table.outFields = ["*"];
							//table.outFields = [];
						}else if (tblFields){
							var tblfields:XMLList = tblFields.field;
							table.outFields = [];
							for each (var tblfieldXML:XML in tblfields){
								if (tblfieldXML.@name[0])
									table.outFields.push(tblfieldXML.@name[0]);
							}
						}
						
						var searchTable:Object = {
							table: table,
							label: tblLabel,
							titlefield: tblTitleField,
							expr: configTableExprs,
							fields: tblFields,
							links: tblLinks,
							multi: tblMultiImgField,
							enableexport: tblEnableExport,
							defexpr: tblDefExpr,
							opendg: tblopenDG,
							relates: configTableRels
						}
						
						if (tblExpr){
							configSearchText.push(searchTable);
							if(i==0){
								qLayer = new FeatureLayer(tblURL);
								if(configTableExprs[0].usedomain)
									popCBwithDomain(configTableExprs[0].field);
								else if(configTableExprs[0].userlist != "")
									popCBwithUserList(configTableExprs[0].userlist);
							}
						}
					}
//-----------------------------------------------------------------------------------------------------					
					//marker symbol
					if(configXML.symbols.picturemarkersymbol.@url[0] != null){
						const resultMarkerSymbolURL:String = configXML.symbols.picturemarkersymbol.@url || widgetIcon;
						const resultMarkerSymbolHeight:Number = (configXML.symbols.picturemarkersymbol.@height[0] != null) ? configXML.symbols.picturemarkersymbol.@height : 30;
						const resultMarkerSymbolWidth:Number = (configXML.symbols.picturemarkersymbol.@width[0] != null) ? configXML.symbols.picturemarkersymbol.@width : 30;
						const resultMarkerSymbolXOffset:Number = configXML.symbols.picturemarkersymbol.@xoffset || 0;
						const resultMarkerSymbolYOffset:Number = configXML.symbols.picturemarkersymbol.@yoffset || 0;
						resultMarkerSymbol = new PictureMarkerSymbol(resultMarkerSymbolURL, resultMarkerSymbolWidth, resultMarkerSymbolHeight, resultMarkerSymbolXOffset, resultMarkerSymbolYOffset);
					}else{
						const resultMarkerSymbolStyle:String = configXML.symbols.simplemarkersymbol.@style || "circle";
						const resultMarkerSymbolSize:Number = (configXML.symbols.simplemarkersymbol.@size[0] != null) ? configXML.symbols.simplemarkersymbol.@size : 15;
						const resultMarkerSymbolColor:uint = (configXML.symbols.simplemarkersymbol.@color[0] != null) ? configXML.symbols.simplemarkersymbol.@color : 0x5F9E61;
						const resultMarkerSymbolAlpha:Number = (configXML.symbols.simplemarkersymbol.@alpha[0] != null) ? configXML.symbols.simplemarkersymbol.@alpha : 0.8;
						const resultMarkerSymbolXOffset2:Number = configXML.symbols.simplemarkersymbol.@xoffset || 0;
						const resultMarkerSymbolYOffset2:Number = configXML.symbols.simplemarkersymbol.@yoffset || 0;
						const resultMarkerSymbolAngle:Number = configXML.symbols.simplemarkersymbol.@angle || 0;
						const resultMarkerSymbolOutlineStyle:String = configXML.symbols.simplemarkersymbol.outline.@style || "solid";
						const resultMarkerSymbolOutlineColor:uint = (configXML.symbols.simplemarkersymbol.outline.@color[0] != null) ? configXML.symbols.simplemarkersymbol.outline.@color : 0x0000ff;
						const resultMarkerSymbolOutlineAlpha:Number = (configXML.symbols.simplemarkersymbol.outline.@alpha[0] != null) ? configXML.symbols.simplemarkersymbol.outline.@alpha : 0.8;
						const resultMarkerSymbolOutlineWidth:Number = (configXML.symbols.simplemarkersymbol.outline.@width[0] != null) ? configXML.symbols.simplemarkersymbol.outline.@width : 2;
						resultMarkerSymbol = new SimpleMarkerSymbol(resultMarkerSymbolStyle,resultMarkerSymbolSize,resultMarkerSymbolColor,resultMarkerSymbolAlpha,resultMarkerSymbolXOffset2,resultMarkerSymbolYOffset2,resultMarkerSymbolAngle,new SimpleLineSymbol(resultMarkerSymbolOutlineStyle, resultMarkerSymbolOutlineColor, resultMarkerSymbolOutlineAlpha, resultMarkerSymbolOutlineWidth));
					}
					
					//Symbol for stand alone tables
					resultSATSymbol = new PictureMarkerSymbol(satClass,20,20);
					
					//line symbol
					const resultLineSymbolColor:uint = (configXML.symbols.simplelinesymbol.@color[0] != null) ? configXML.symbols.simplelinesymbol.@color : 0x5F9E61;
					const resultLineSymbolAlpha:Number = (configXML.symbols.simplelinesymbol.@alpha[0] != null) ? configXML.symbols.simplelinesymbol.@alpha : 0.8;
					const resultLineSymbolWidth:Number = (configXML.symbols.simplelinesymbol.@width[0] != null) ? configXML.symbols.simplelinesymbol.@width : 2;
					resultLineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, resultLineSymbolColor, resultLineSymbolAlpha, resultLineSymbolWidth);
					
					// fill symbol
					const resultFillSymbolColor:uint = (configXML.symbols.simplefillsymbol.@color[0] != null) ? configXML.symbols.simplefillsymbol.@color : 0x5F9E61;
					const resultFillSymbolAlpha:Number = (configXML.symbols.simplefillsymbol.@alpha[0] != null) ? configXML.symbols.simplefillsymbol.@alpha : 0.5; 
					const resultFillSymbolOutlineColor:uint = (configXML.symbols.simplefillsymbol.outline.@color[0] != null) ? configXML.symbols.simplefillsymbol.outline.@color : 0x5F9E61;
					const resultFillSymbolOutlineAlpha:Number = (configXML.symbols.simplefillsymbol.outline.@alpha[0] != null) ? configXML.symbols.simplefillsymbol.outline.@alpha : 0.8;
					const resultFillSymbolOutlineWidth:Number = (configXML.symbols.simplefillsymbol.outline.@width[0] != null) ? configXML.symbols.simplefillsymbol.outline.@width : 2;
					resultFillSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, resultFillSymbolColor, resultFillSymbolAlpha, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, resultFillSymbolOutlineColor, resultFillSymbolOutlineAlpha, resultFillSymbolOutlineWidth));
					
					graphicsLayerBuffer = new GraphicsLayer();
					graphicsLayerBuffer.name = "Search Buffer Results";
					graphicsLayerBuffer.id = "buff";
					map.addLayer(graphicsLayerBuffer);
					
					graphicsLayer = new GraphicsLayer();
					graphicsLayer.name = "Search Results";
					
					graphicsLayer.id = "graResult";
					graphicsLayer.symbol = resultMarkerSymbol;
					graphicsLayer.clusterer = clusterer;
					graphicsLayer.addEventListener(FlareMouseEvent.FLARE_CLICK, flareClickHandler);
					
					graphicsLayer.addEventListener(FlexEvent.HIDE, graphicsLayer_hideHandler);
					map.addLayer(graphicsLayer);
					
					graGraphicsLayer = new GraphicsLayer();
					graGraphicsLayer.id = "gra";
					graGraphicsLayer.name = "Graphical Search Layer";
					map.addLayer(graGraphicsLayer);
					
					var userTolerance:Number = Number(configXML.toleranceforpointgraphicalselection);
					if (userTolerance > 0)
						pointSearchTolerance = userTolerance;
					if (selectedGraphicalTool != "" && defaultSelectionOption == "graphicalInput")
						activateSearchTool(null, selectedGraphicalTool);
				}
				
				if(disableButtons != "")
					var dbArr:Array = disableButtons.split(",");
				
				var disText:Boolean = false;
				var disGra:Boolean = false;
				var disSpat:Boolean = false;
				var disGrid:Boolean = false;
				var disDataGrid:Boolean = false;
				if(dbArr){
					for (var d:int = 0; d<dbArr.length; d++){
						switch (dbArr[d]){
							case "text":{
								disText = true;
								break;
							}
							case "graphic":{
								disGra = true;
								break;
							}
							case "spatial":{
								disSpat = true;
								break;
							}
							case "grid":{
								disGrid = true;
								break;
							}
							case "datagrid":{
								disDataGrid = true;
								break;
							}
						}
					}
				}
				if(!disGra)
					wTemplate.addTitlebarButton(ICON_URL + "i_searchgraphical.png", graphicalsearchLabel, showStateGraphicalSearch);
				if (configSearchText.length && disText != true)
					wTemplate.addTitlebarButton(ICON_URL + "select_features2.png", textsearchLabel, showStateTextSearch);
				if(!disGrid)
					wTemplate.addTitlebarButton(ICON_URL + "i_clock.png", "Time Settings", showTimeSettings);
				if(!disGrid)
					wTemplate.addTitlebarButton(ICON_URL + "cal.gif", "Choose Fields", showfields);
				if(!disGrid)
					wTemplate.addTitlebarButton(ICON_URL + "i_table.png", resultsLabel, showStateResults);
				
				//Setup Text Search
				if (configSearchText.length){
					cboLayerText.dataProvider = configSearchText;
					txtLabelText.text = configSearchText[0].expr[0].textlabel;
					if (configSearchText.length == 1)
					{
						boxText.visible = false;
						boxText.includeInLayout = false;
					}
					cboLayerExpr.dataProvider = configSearchText[0].expr;
					if (configSearchText[0].expr.length == 1)
					{
						boxTextexpr.visible = false;
						boxTextexpr.includeInLayout = false;
					}
				}else{
					boxText.visible = false;
					txtLabelText.text = nolayerLabel;
				}
				
				//Setup Graphical Search
				if (configSearchGraphical.length){
					cboLayerGraphical.dataProvider = configSearchGraphical;
					txtLabelGraphical.text = configSearchText[0].graphicallabel;
					if (configSearchGraphical.length == 1){
						boxGraphical.visible = false;
						boxGraphical.includeInLayout = false;
					}
				}else{
					boxGraphical.visible = false;
					txtLabelGraphical.text = nolayerLabel;
				}
				
				//Determine which button to select based on the default selection option
				for(var tb:int=0; tb < wTemplate.headerToolGroup.numElements; tb++){
					var tbb:TitlebarButton = wTemplate.headerToolGroup.getElementAt(tb) as TitlebarButton;
					if(tbb.toolTip == graphicalsearchLabel && defaultSelectionOption == "graphicalInput")
						wTemplate.selectedTitlebarButtonIndex = tb;
					if(tbb.toolTip == textsearchLabel && defaultSelectionOption == "textInput")
						wTemplate.selectedTitlebarButtonIndex = tb;
				}
				
				AppEvent.addListener(AppEvent.DATA_PUBLISH, sharedDataUpdated);
				
				wTemplate.visible = true;
				txtSearch.addEventListener(FlexEvent.ENTER, equeryFeaturesText);
				searchBtn.addEventListener(MouseEvent.CLICK, equeryFeaturesText);
				
				///This is to dynamically add species name and other parameters to combobox this comes straight from Oracle
				var IchSpecies:QueryTask = new QueryTask(configXML.dataproviders.ichSpeciesArray);
				var TrawlSpecies:QueryTask = new QueryTask(configXML.dataproviders.trawlSpeciesArray);
				var cruiseCall:QueryTask = new QueryTask(configXML.dataproviders.cruiseArray);
				var cruiseCall_chlor:QueryTask = new QueryTask(configXML.dataproviders.cruiseArray_chlor);
				var cruiseCall_nutr:QueryTask = new QueryTask(configXML.dataproviders.cruiseArray_nutrient);
				var cruiseCall_seacat:QueryTask = new QueryTask(configXML.dataproviders.cruiseArray_seacat);
				var cruiseCall_ctdb:QueryTask = new QueryTask(configXML.dataproviders.cruiseArray_ctdb);
				var taxonCall:QueryTask = new QueryTask(configXML.dataproviders.taxonArray);
				var geoCall:QueryTask = new QueryTask(configXML.dataproviders.geo_loc);
				var gearCall:QueryTask = new QueryTask(configXML.dataproviders.gearArray);
				if(tokenUse != ""){
					IchSpecies.token = tokenUse;
					TrawlSpecies.token = tokenUse;
					cruiseCall.token = tokenUse;
					cruiseCall_nutr.token = tokenUse;
					cruiseCall_seacat.token = tokenUse;
					cruiseCall_ctdb.token = tokenUse;
					cruiseCall_chlor.token = tokenUse;
					taxonCall.token = tokenUse;
					geoCall.token = tokenUse;
					gearCall.token = tokenUse;
				}
				TrawlSpecies.useAMF = true;
				IchSpecies.useAMF = true;
				cruiseCall.useAMF = true;
				taxonCall.useAMF = true;
				cruiseCall_nutr.useAMF = true
				cruiseCall_seacat.useAMF = true;
				cruiseCall_ctdb.useAMF = true;
				cruiseCall_chlor.useAMF = true;
				geoCall.useAMF = true;
				gearCall.useAMF = true;
				var iQuery:Query = new Query();
				iQuery.outFields=['*'];
				iQuery.where = "1=1";
				IchSpecies.execute(iQuery,new AsyncResponder(onResultIch,onFault));
				TrawlSpecies.execute(iQuery,new AsyncResponder(onResulttraw,onFault));
				cruiseCall.execute(iQuery,new AsyncResponder(onResultCruise,onFault));
				cruiseCall_nutr.execute(iQuery,new AsyncResponder(onResultCruiseN,onFault));
				cruiseCall_seacat.execute(iQuery,new AsyncResponder(onResultCruiseS,onFault));
				cruiseCall_ctdb.execute(iQuery,new AsyncResponder(onResultCruiseC,onFault));
				cruiseCall_chlor.execute(iQuery,new AsyncResponder(onResultCruiseCH,onFault));
				taxonCall.execute(iQuery,new AsyncResponder(onResulttaxon,onFault));
				geoCall.execute(iQuery,new AsyncResponder(onResultgeo,onFault));
				gearCall.execute(iQuery,new AsyncResponder(onResultgear,onFault));
				
				function onResultgeo(featureSet:FeatureSet, token:Object = null):void
				{
					var obj:Object = new Object;
					obj.alias = "SELECT ALL";
					obj.selectall = true;
					geo_locArray= new ArrayCollection();
					geo_locArray.addItem(obj);
					for (var p:int=0;p < featureSet.attributes.length; p++){
						geo_locArray.addItem({alias:featureSet.attributes[p].GEOGRAPHIC_AREA,selectall:false});
					}
					geo_locArray.refresh();
					geolocSample.dataProvider =geo_locArray;
				}
				function onResultIch(featureSet:FeatureSet, token:Object = null):void
				{
					var obj:Object = new Object;
					obj.alias = "SELECT ALL";
					obj.selectall = true;
					speciesIchArray= new ArrayCollection();
					speciesIchArray.addItem(obj);
					for (var p:int=0;p < featureSet.attributes.length; p++){
						speciesIchArray.addItem({alias:featureSet.attributes[p].SPECIES_NAME,selectall:false});
					}
					speciesIchArray.refresh();
					speciesIch.dataProvider =speciesIchArray;
				}
				function onResulttraw(featureSet:FeatureSet, token:Object = null):void
				{
					var obj:Object = new Object;
					obj.alias = "SELECT ALL";
					obj.selectall = true;
					speciesTrawlArray = new ArrayCollection();
					speciesTrawlArray.addItem(obj);
					for (var p:int=0;p < featureSet.attributes.length; p++){
						speciesTrawlArray.addItem({alias:featureSet.attributes[p].SPECIES_NAME,selectall:false});
					}
					speciesTrawlArray.refresh();
					speciesTra.dataProvider= speciesTrawlArray;
				}
				function onResultCruiseS(featureSet:FeatureSet, token:Object = null):void
				{
					var obj:Object = new Object;
					obj.alias = "SELECT ALL";
					obj.selectall = true;
					cruiseArray_seacat= new ArrayCollection();
					cruiseArray_seacat.addItem(obj);
					for (var p:int=0;p < featureSet.attributes.length; p++){
						cruiseArray_seacat.addItem({alias:featureSet.attributes[p].CRUISE,selectall:false});
					}
					cruiseArray_seacat.refresh();
				}
				function onResultCruiseN(featureSet:FeatureSet, token:Object = null):void
				{
					var obj:Object = new Object;
					obj.alias = "SELECT ALL";
					obj.selectall = true;
					cruiseArray_nutr= new ArrayCollection();
					cruiseArray_nutr.addItem(obj);
					for (var p:int=0;p < featureSet.attributes.length; p++){
						cruiseArray_nutr.addItem({alias:featureSet.attributes[p].CRUISE,selectall:false});
					}
					cruiseArray_nutr.refresh();
				}
				function onResultCruiseCH(featureSet:FeatureSet, token:Object = null):void
				{
					var obj:Object = new Object;
					obj.alias = "SELECT ALL";
					obj.selectall = true;
					cruiseArray_ctdb= new ArrayCollection();
					cruiseArray_ctdb.addItem(obj);
					for (var p:int=0;p < featureSet.attributes.length; p++){
						cruiseArray_ctdb.addItem({alias:featureSet.attributes[p].CRUISE,selectall:false});
					}
					cruiseArray_ctdb.refresh();
				}
				function onResultCruiseC(featureSet:FeatureSet, token:Object = null):void
				{
					var obj:Object = new Object;
					obj.alias = "SELECT ALL";
					obj.selectall = true;
					cruiseArray_chlor= new ArrayCollection();
					cruiseArray_chlor.addItem(obj);
					for (var p:int=0;p < featureSet.attributes.length; p++){
						cruiseArray_chlor.addItem({alias:featureSet.attributes[p].CRUISE,selectall:false});
					}
					cruiseArray_chlor.refresh();
				}
				function onResultCruise(featureSet:FeatureSet, token:Object = null):void
				{
					var obj:Object = new Object;
					obj.alias = "SELECT ALL";
					obj.selectall = true;
					cruiseArray= new ArrayCollection();
					cruiseArray.addItem(obj);
					for (var p:int=0;p < featureSet.attributes.length; p++){
						cruiseArray.addItem({alias:featureSet.attributes[p].CRUISE_NAME,selectall:false});
					}
					cruiseArray.refresh();
					cruiseSample.dataProvider = cruiseArray;
				}	
				function onResulttaxon(featureSet:FeatureSet, token:Object = null):void
				{
					var obj:Object = new Object;
					obj.alias = "SELECT ALL";
					obj.selectall = true;
					taxonArray = new ArrayCollection();
					taxonArray.addItem(obj);
					for (var p:int=0;p < featureSet.attributes.length; p++){
						taxonArray.addItem({alias:featureSet.attributes[p].TAXON_NAME,selectall:false});
					}
					taxonArray.refresh();
					taxaBob.dataProvider = taxonArray;
				}
				function onFault(info:Object, token:Object = null):void
				{
					Alert.show(info.toString(), "Query Problem");
				}
				function onResultgear(featureSet:FeatureSet, token:Object = null):void
				{
					var obj:Object = new Object;
					obj.alias = "SELECT ALL";
					obj.selectall = true;
					gearnamesArray = new ArrayCollection();
					gearnamesArray.addItem(obj);
					for (var p:int=0;p < featureSet.attributes.length; p++){
						gearnamesArray.addItem({alias:featureSet.attributes[p].GEAR_NAME,selectall:false});
					}
					gearnamesArray.refresh();
					gearSample.dataProvider = gearnamesArray;
				}
				/* var gearArray:Array = String(configXML.gearnames).split(',');
				var objG:Object = new Object;
				objG.alias = "SELECT ALL";
				objG.selectall = true;
				gearnamesArray= new ArrayCollection();
				gearnamesArray.addItem(objG);
				for (var g:int=0;g < gearArray.length; g++){
					gearnamesArray.addItem({alias:gearArray[g],selectall:false});
				}
				gearnamesArray.refresh();
				gearSample.dataProvider = gearnamesArray;	 */			
				
				//add years dynamic for this year - 10 years or 1
				var nd:Date = new Date;
				if(configXML.publicSite == "true"){
					nd.fullYear = nd.fullYear - 10;
				}
				for (var q:int=1972;q < nd.fullYear+1; q++)
				{
					/* if(q>1984){
						yearArray.addItem({'gridfield':'true','alias':q});
					}
					else{
						yearArray.addItem({'gridfield':'false','alias':q});
					} */
					yearArray.addItem({'gridfield':'true','alias':q});
				}
				var dataSortField:SortField = new SortField();
				dataSortField.name = "alias";
				dataSortField.numeric = true;
				var numericDataSort:Sort = new Sort();
				numericDataSort.fields = [dataSortField];
				numericDataSort.reverse();
				
				yearArray.sort = numericDataSort;
				yearArray.refresh();
				dgYear.dataProvider.refresh();
				
				dayArray.sort = numericDataSort;
				dgDay.dataProvider.refresh();
				dgDay.dataProvider = dayArray;
				dgMonth.dataProvider = monthArray;
				
				monthArray.refresh();
				dgMonth.dataProvider.refresh();
			}			
			
			
			
			private function flareClickHandler(event:MouseEvent):void
			{
				var searchResult:SearchResult = event.target.cluster.graphics[0].attributes as SearchResult;
				clearTimeout(hitimer);
				hitimer = setTimeout(showHighlight, 300, [searchResult]);
			}
			
			private function pointClickHandler(event:MouseEvent):void
			{
				var searchResult:SearchResult = event.target.attributes as SearchResult;
				clearTimeout(hitimer);
				hitimer = setTimeout(showHighlight, 300, [searchResult]);
			}
			
			private function myFaultFunction(fault:Fault,ob:Object):void
			{
				trace(fault.faultString);
			}
			
			private function myResultFunctionGraphical(result:Object, token:Object = null):void
			{
				if (result is LayerDetails)
				{
					fieldsArray2.removeAll();
					for each (var field:Field in LayerDetails(result).fields)
					{
						if(field.alias.toLowerCase() == "h_id"||field.alias.toLowerCase() == "objectid"||field.alias.toLowerCase() == "tc_id"||field.alias.toLowerCase() == "objectid_1")
						{
							//do nothing
						}
						else{
							//set a few attributes default to return 
							var newFld:Object = new Object;
							if(field.name.search("HAUL")>-1 || field.name.search("SAMPLE")>-1|| field.name.search("NAME")>-1){
								newFld['gridfield'] = "true";
							}
							else{
								newFld['gridfield'] = "false";
							} 
							newFld['name'] = field.name;
							newFld['alias'] = field.alias;
							fieldsArray2.addItem(newFld);
						}
					}
					var dataSortField:SortField = new SortField();
					dataSortField.name = "gridfield";
					dataSortField.numeric = false;
					var numericDataSort:Sort = new Sort();
					numericDataSort.fields = [dataSortField];
					
					fieldsArray2.sort = numericDataSort;
					fieldsArray2.refresh();
					dg2.dataProvider = fieldsArray2;
				}
			}
			
			//get layer/table fields
			private function myResultFunction(result:Object, token:Object = null):void
			{
				fieldsArray.removeAll();
				if (result is LayerDetails)
				{
					for each (var field:Field in LayerDetails(result).fields)
					{
						if(field.alias.toLowerCase() == "h_id"||field.alias.toLowerCase() == "objectid"||field.alias.toLowerCase() == "tc_id"||field.alias.toLowerCase() == "objectid_1")
						{
						}
						else{
							var newFld:Object = new Object;
							//set a few attributes default to return 
							if(field.name.search("HAUL")>-1 || field.name.search("SAMPLE")>-1|| field.name.search("NAME")>-1){
								newFld['gridfield'] = "true";
							}
							else{
								newFld['gridfield'] = "false";
							} 
							newFld['name'] = field.name;
							newFld['alias'] = field.alias;
							fieldsArray.addItem(newFld);
						}
					}
					var dataSortField:SortField = new SortField();
					dataSortField.name = "name";
					dataSortField.numeric = false;
					var numericDataSort:Sort = new Sort();
					numericDataSort.fields = [dataSortField];
					
					fieldsArray.sort = numericDataSort;
					fieldsArray.refresh();
					dg.dataProvider = fieldsArray;
				}
				else if (result is TableDetails)
				{
					for each (var field1:Field in TableDetails(result).fields)
					{
						if(field1.alias.toLowerCase() == "h_id"||field1.alias.toLowerCase() == "objectid"||field1.alias.toLowerCase() == "tc_id"||field1.alias.toLowerCase() == "objectid_1")
						{
						}
						else{
							var newFld1:Object = new Object;
							//set a few attributes default to return 
							if(field1.name.search("NAME")>-1 || field1.name.search("ID")>-1){
								newFld1['gridfield'] = "true";
							}
							else{
								newFld1['gridfield'] = "false";
							}
							newFld1['name'] = field1.name;
							newFld1['alias'] = field1.alias;
							fieldsArray.addItem(newFld1);
						}
					}
					dg.dataProvider = fieldsArray;
				}
				fieldResultMain = ObjectUtil.copy( fieldsArray ) as ArrayCollection;
			}
			
			private function equeryFeaturesText(evt:Event):void
			{
				queryFeaturesText2();	
			}
			
			private function getSopImg(value:String):String
			{
				var retVal:String = ""
				switch(value)
				{
					case "esriSpatialRelIntersects":
					{
						retVal = WIDGET_URL + "i_intersect.png";
						break;
					}
					case "esriSpatialRelContains":
					{
						retVal = WIDGET_URL + "i_contain.png";
						break;
					}
					case "esriSpatialRelCrosses":
					{
						retVal = WIDGET_URL + "i_crosses.png";
						break;
					}
					case "esriSpatialRelEnvelopeIntersects":
					{
						retVal = WIDGET_URL + "i_envintersects.png";
						break;
					}
					case "esriSpatialRelIndexIntersects":
					{
						retVal = WIDGET_URL + "i_index.png";
						break;
					}
					case "esriSpatialRelOverlaps":
					{
						retVal = WIDGET_URL + "i_overlaps.png";
						break;
					}
					case "esriSpatialRelTouches":
					{
						retVal = WIDGET_URL + "i_touches.png";
						break;
					}
					case "esriSpatialRelWithin":
					{
						retVal = WIDGET_URL + "i_within.png";
						break;
					}
				}
				return retVal;
			}			
			
			private function searchLayerChangedText():void
			{
				var i:Number = cboLayerText.selectedIndex;
				
				//only show spatial search otption if there is a geometry layer
				//currently specimen and subspecimen
				if(String(configSearchText[i].label).search('SPECIMEN') > -1||String(configSearchText[i].label).search('SAMPLE') > -1)
				{
					multipleSearch = true;
					spatLayer = true;
					if(databaseText.selectedLabel == 'Zooplankton')
					{
						ichOptions = false;
						trawlOptions = false;
						bobOptions = true;
						bobGroup.includeInLayout = true;
						trawlGroup.includeInLayout = false;
						ichGroup.includeInLayout = false;
						bobGroup.visible = true;
						trawlGroup.visible = false;
						ichGroup.visible = false;
					}
					if(databaseText.selectedLabel == 'TRAWL')
					{
						ichOptions = false;
						trawlOptions = true;
						bobOptions = false;
						bobGroup.includeInLayout = false;
						trawlGroup.includeInLayout = true;
						ichGroup.includeInLayout = false;
						bobGroup.visible = false;
						trawlGroup.visible = true;
						ichGroup.visible = false;
					}
					if(databaseText.selectedLabel == 'Ichthyoplankton')
					{
						ichOptions = true;
						trawlOptions = false;
						bobOptions = false;
						bobGroup.includeInLayout = false;
						trawlGroup.includeInLayout = false;
						ichGroup.includeInLayout = true;
						bobGroup.visible = false;
						trawlGroup.visible = false;
						ichGroup.visible = true;
					}
				}
				else{
					multipleSearch = false;
					spatLayer = false;
					ichOptions = false;
					trawlOptions = false;
					bobOptions = false;
				}
				if(String(configSearchText[i].label).search('HAUL') > -1||String(configSearchText[i].label).search('SEACAT')>-1||String(configSearchText[i].label).search('CTDB')>-1||String(configSearchText[i].label).search('CHLOROPHYLL')>-1||String(configSearchText[i].label).search('NUTRIENT')>-1)
				{
					trawlOptions = false;
					bobOptions = false;
					bobGroup.includeInLayout = false;
					haulSearch = true;
					microZoopVisible = false;
					databaseTypeLabel.visible = false;
					databaseText.visible = false;
					sampleBlock.visible = true;
				}
				else{
					microZoopVisible = false;
					databaseTypeLabel.visible = true;
					databaseText.visible = true;
					sampleBlock.visible = true;
					databaseTypeLabel.text = "Choose Sample Type";
					haulSearch = false;
				}
				//setup relationship query if smaple or specimen results have been shown
				if(sampleType == "sample" && graphicsLayer.graphicProvider.length>0){
					//set up association query - if samples are returned allow show button - these related to samples
					if(String(configSearchText[i].label).search('SEACAT')>-1||String(configSearchText[i].label).search('CTDB')>-1||String(configSearchText[i].label).search('CHLOROPHYLL')>-1||String(configSearchText[i].label).search('NUTRIENT')>-1){
						associationOptions = true;
					}
					else{
						associationOptions = false;
					}	
				}
				else if(sampleType == "specimen"&& graphicsLayer.graphicProvider.length>0){
					//set up association query - if samples are returned allow show button- these related to specimen Trawl
					if(String(configSearchText[i].label).search('DIET')>-1||String(configSearchText[i].label).search('SUBSPECIMEN')>-1){
						associationOptions = true;
					}
					else{
						associationOptions = false;
					}
				}
				else{
					associationOptions = false;
				}
				
				if(String(configSearchText[i].label).search('SPECIMEN') > -1||String(configSearchText[i].label).search('CTD') > -1||String(configSearchText[i].label).search('HAUL') > -1||String(configSearchText[i].label).search('SAMPLE') > -1||String(configSearchText[i].label).search('CHLOROPHYLL')>-1||String(configSearchText[i].label).search('NUTRIENT')>-1||String(configSearchText[i].label).search('DIET')>-1)
				{
					spatLayer = true;
					if(graGraphicsLayer.graphicProvider.length> 0)
					{
						useSpatial.visible= true;
					}
					else{
						useSpatial.visible= false;
					}
					if(String(configSearchText[i].label).search('SAMPLE') > -1)
					{
						sampleSearch = true;
						bobGroup.includeInLayout = false;
						trawlGroup.includeInLayout = false;
						ichGroup.includeInLayout = false;
						bobGroup.visible = false;
						trawlGroup.visible = false;
						ichGroup.visible = false;
					}	
					else{
						sampleSearch = false;
					}
					resultLoc.text ="*Results will be shown on map and in table.";
				}
				else{
					spatLayer = false;
					useSpatial.selected= false;
					sampleSearch = false;
					resultLoc.text ="*Results will be shown in table only.";
				}
				
				//remove optional attribute combobox/text input
				if(String(configSearchText[i].label).search('SAMPLE') > -1 ||String(configSearchText[i].label).search('SPECIMEN') > -1||String(configSearchText[i].label).search('HAUL') > -1)
				{
					optionAttribute = false;
				}
				else{
					optionAttribute = true;
				}
				
				//Haul table parameters
				if(String(configSearchText[i].label).search('HAUL') > -1){
					spatLayer = true;
					multipleSearch = true;
					microZoopVisible = false;
				}
				//add on for spatial type layers
				if(String(configSearchText[i].label).search('SEACAT')>-1||String(configSearchText[i].label).search('CTDB')>-1||String(configSearchText[i].label).search('CHLOROPHYLL')>-1||String(configSearchText[i].label).search('NUTRIENT')>-1){
					haulSearch = true;
					multipleSearch = true;
					optionAttribute = false;
					hideotherOptions = false;
				}
				else{
					hideotherOptions = true;
				}
				
				if(String(configSearchText[i].label).search('SUBSPECIMEN') > -1)
				{
					microZoopVisible = true;
					ichGroup.visible = true;
					ichOptions = true;
					ichGroup.includeInLayout = true;
					trawlOptions = false;
					bobOptions = false;
					bobGroup.includeInLayout = false;
					databaseTypeLabel.text = "Ichthyoplankton Database     ";
					databaseTypeLabel.visible = true;
				}
				
				//select out different cruises based on data set
				if(String(configSearchText[i].label).search('SEACAT')>-1){
					cruiseSample.dataProvider = cruiseArray_seacat;	
				}
				else if(String(configSearchText[i].label).search('CTDB')>-1){
					cruiseSample.dataProvider = cruiseArray_ctdb;	
				}
				else if(String(configSearchText[i].label).search('CHLOR')>-1){
					cruiseSample.dataProvider = cruiseArray_chlor;	
				}
				else if(String(configSearchText[i].label).search('NUTRIENT')>-1){
					cruiseSample.dataProvider = cruiseArray_nutr;	
				}
				else{
					cruiseSample.dataProvider = cruiseArray;	
				}		
				
				cbSearch.visible = false;
				cbSearch.includeInLayout = false;
				txtSearch.visible = true;
				txtSearch.includeInLayout = true;
				txtSearch.restrict = null;
				txtSearch.errorString = "";
				if(numberValidator){
					numberValidator.property = "";
					numberValidator.source = null;
				}
					
				txtSearch.addEventListener(FlexEvent.ENTER, equeryFeaturesText);
				searchBtn.addEventListener(MouseEvent.CLICK, equeryFeaturesText);
				if(configSearchText[i].expr[0].usedomain)
					popCBwithDomain(configSearchText[i].expr[0].field);
				else if(configSearchText[i].expr[0].userlist != "")
					popCBwithUserList(configSearchText[i].expr[0].userlist);
				txtLabelText.text = configSearchText[i].expr[0].textlabel;
				cboLayerExpr.dataProvider = configSearchText[i].expr;
				if (configSearchText[i].expr.length == 1 && optionAttribute == false)
				{
					boxTextexpr.visible = false;
					boxTextexpr.includeInLayout = false;
				}else if(optionAttribute == true){
					boxTextexpr.visible = true;
					boxTextexpr.includeInLayout = true;
				}
				
				//create checklist array of fields
				var layURL:String;
				var layTOKEN:String = "";
				if(configSearchText[i].layer == "undefined" ||configSearchText[i].layer == null)
				{
					layURL = configSearchText[i].table.url;
					layTOKEN = configSearchText[i].table.token;
				}
				else
				{
					layURL = configSearchText[i].layer.url;
					layTOKEN = configSearchText[i].layer.token;
				}
				var urlArr:Array = layURL.split("/");
				var layer2:ArcGISDynamicMapServiceLayer= new ArcGISDynamicMapServiceLayer(layURL);
				if(layTOKEN != "")
				{
					layer2.token = layTOKEN;
				}
				layer2.getDetails(urlArr[urlArr.length-1], new AsyncResponder(myResultFunction, myFaultFunction));
			}
			
			private function searchLayerExprChangedText():void
			{
				var i:Number = cboLayerText.selectedIndex;
				var j:Number = cboLayerExpr.selectedIndex;
				cbSearch.visible = false;
				cbSearch.includeInLayout = false;
				txtSearch.visible = true;
				txtSearch.includeInLayout = true;
				if(numberValidator){
					numberValidator.property = "";
					numberValidator.source = null;
				}
				searchBtn.addEventListener(MouseEvent.CLICK, equeryFeaturesText);
				txtSearch.addEventListener(FlexEvent.ENTER, equeryFeaturesText);
				if(configSearchText[i].expr[j].usedomain)
					popCBwithDomain(configSearchText[i].expr[j].field);
				else if(configSearchText[i].expr[j].userlist != "")
					popCBwithUserList(configSearchText[i].expr[j].userlist);
				txtLabelText.text = configSearchText[i].expr[j].textlabel;
			}
			
			private function searchLayerChangedGraphical():void
			{
				var i:Number = cboLayerGraphical.selectedIndex;
				txtLabelGraphical.text = configSearchText[i].graphicallabel;
				
				//create checklist array of fields
				var layURL:String;
				var layTOKEN:String = "";
				if(configSearchText[i].layer == "undefined" ||configSearchText[i].layer == null)
				{
					layURL = configSearchText[i].table.url;
					layTOKEN = configSearchText[i].table.token;
				}
				else
				{
					layURL = configSearchText[i].layer.url;
					layTOKEN = configSearchText[i].layer.token;
				}
				var urlArr:Array = layURL.split("/");
				var layer2:ArcGISDynamicMapServiceLayer= new ArcGISDynamicMapServiceLayer(layURL);
				if(layTOKEN != "")
				{
					layer2.token = layTOKEN;
				}
				layer2.getDetails(urlArr[urlArr.length-1], new AsyncResponder(myResultFunctionGraphical, myFaultFunction));
			}
			
			private function activateSearchTool(event:MouseEvent, lTool:String = ""):void
			{
				addSharedData("Deactivate_DrawTool", null); // to be able to deactivate drawTool on other widgets
				
				if(event){
					graGraphicsLayer.clear();
					selectedDrawingIcon = Image(event.currentTarget);
				}else{
					switch(lTool){
						case DrawTool.EXTENT :
						{
							selectedDrawingIcon = iSearchExt;
							break;
						}
						case DrawTool.POLYGON :
						{
							selectedDrawingIcon = iSearchPoly;
							break;
						}
						case DrawTool.MAPPOINT :
						{
							selectedDrawingIcon = iSearchPnt;
							break;
						}
						case DrawTool.POLYLINE :
						{
							selectedDrawingIcon = iSearchLine;
							break;
						}
						default:
						{
							selectedDrawingIcon = iSearchPnt;
						}
					}
				}
				clearSelectionFilter();
				selectedDrawingIcon.filters = [ glowFilter ];
				
				var status:String;
				var value:String = lastTool = selectedDrawingIcon.name;
				switch (value)
				{
					case DrawTool.MAPPOINT:
					{
						status = pointLabel;
						drawSymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE, 15, 0xE01B3C, 1);
						break;
					}
					case DrawTool.POLYLINE:
					{
						status = lineLabel;
						drawSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, 0xE01B3C, 1, 1);
						break;
					}
					case DrawTool.EXTENT:
					{
						status = rectangleLabel;
						drawSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_NULL, 0x3FAFDC, 0.5, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, 0xE01B3C, 1, 4));
						break;
					}
					case DrawTool.POLYGON:
					{
						status = polygonLabel;
						drawSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_NULL, 0x3FAFDC, 0.5, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, 0xE01B3C, 1, 4));
						break;
					}
				}
				setMapAction(value, status, drawSymbol, searchDrawEnd);
			}			
			
			private function searchDrawEnd(event:DrawEvent):void
			{
				activateSearchTool(null,lastTool);
				var geom:Geometry = event.graphic.geometry;
				var graGraphic:Graphic = new Graphic(geom, drawSymbol);
				
				graGraphicsLayer.maintainProjectionCenter = true;
				//allow underlaying points to be interactive
				graGraphic.mouseEnabled = false;
				graGraphicsLayer.mouseEnabled = false;
				graGraphicsLayer.add(graGraphic);
				graGraphicsLayer.visible = true;
				
				if(!graMultiChk.selected){
					//queryFeaturesGra();
				}
			}
			
			private function graMultiChanged():void
			{
				(graMultiChk.selected) ? graFeatureQueryBtn.visible = true : graFeatureQueryBtn.visible = false;
			}
			
			private function unionGeoms2(gl:GraphicsLayer):Geometry
			{
				var retGeom:Geometry;
				var mPoint:Multipoint = new Multipoint(null);
				mPoint.spatialReference = map.spatialReference;
				var mPoly:Polygon = new Polygon(null);
				mPoly.spatialReference = map.spatialReference;
				var mPolyL:Polyline = new Polyline(null);
				mPolyL.spatialReference = map.spatialReference;
				var rType:String;
				for each (var graphic:Graphic in gl.graphicProvider)
				{
					if(graphic.geometry.type == "esriGeometryPoint" && !addTolerance.selected)
					{
						mPoint.addPoint(graphic.geometry as MapPoint);
						rType = "point";
					}else if (graphic.geometry.type == "esriGeometryPoint" && addTolerance.selected){
						var ext2:Extent = createExtentAroundMapPoint(graphic.geometry as MapPoint, pointSearchTolerance) as Extent;
						var pA2:Array = [];
						pA2.push(new MapPoint(ext2.xmin,ext2.ymin,ext2.spatialReference));
						pA2.push(new MapPoint(ext2.xmin,ext2.ymax,ext2.spatialReference));
						pA2.push(new MapPoint(ext2.xmax,ext2.ymax,ext2.spatialReference));
						pA2.push(new MapPoint(ext2.xmax,ext2.ymin,ext2.spatialReference));
						pA2.push(new MapPoint(ext2.xmin,ext2.ymin,ext2.spatialReference));
						mPoly.addRing(pA2);
						rType = "poly";
						mPoly.spatialReference = ext2.spatialReference;
					}
					
					if(graphic.geometry.type == "esriGeometryMultipoint")
					{
						var mp:Multipoint = graphic.geometry as Multipoint
						var pnts:MapPoint;
						for (var p:int=0;p < mp.points.length; p++)
						{
							mPoint.addPoint(mp.points[p]);
						}
						rType = "point";
					}
					
					if(graphic.geometry.type == "esriGeometryPolygon")
					{
						var poly:Polygon = graphic.geometry as Polygon;
						for (var i2:int = poly.rings.length - 1; i2 >= 0; i2--)
						{
							var ringArray:Array = [];
							for (var j1:int = 0; j1 < poly.rings[i2].length; j1++)
							{
								var mp2:MapPoint = poly.getPoint(i2,j1) as MapPoint;
								mp2.normalize();
								mp2.spatialReference = poly.spatialReference;
								ringArray.push(mp2);
							}
							mPoly.addRing(ringArray);
						}
						rType = "poly";
						mPoly.spatialReference = poly.spatialReference;
					}
					
					if(graphic.geometry.type == "esriGeometryPolyline")
					{
						var polyl:Polyline = graphic.geometry as Polyline;
						for(var l:int=polyl.paths.length-1; l >= 0; l--)
						{
							var pathArray:Array = [];
							for (var j2:int = 0; j2 < polyl.paths[l].length; j2++)
							{
								var mp3:MapPoint = polyl.getPoint(l,j2) as MapPoint;
								mp3.spatialReference = polyl.spatialReference;
								pathArray.push(mp3);
							}
							mPolyL.addPath(pathArray);
						}
						rType = "line";
					}
					
					if(graphic.geometry.type == "esriGeometryEnvelope")
					{
						var ext:Extent = graphic.geometry as Extent;
						var pA:Array = [];
						pA.push(new MapPoint(ext.xmin,ext.ymin,ext.spatialReference));
						pA.push(new MapPoint(ext.xmin,ext.ymax,ext.spatialReference));
						pA.push(new MapPoint(ext.xmax,ext.ymax,ext.spatialReference));
						pA.push(new MapPoint(ext.xmax,ext.ymin,ext.spatialReference));
						pA.push(new MapPoint(ext.xmin,ext.ymin,ext.spatialReference));
						mPoly.addRing(pA);
						rType = "poly";
					}
				}
				
				switch(rType){
					case "point":
					{
						retGeom = mPoint;
						break;
					}
					case "poly":
					{
						retGeom = mPoly;
						break;
					}
					case "line":
					{
						retGeom = mPolyL;
						break;
					}
				}
				return retGeom;
			}
			
			private function queryFeaturesGra():void
			{
				addSharedData("Deactivate_DrawTool", null); // to be able to deactivate drawTool on other widgets
				var geom:Geometry;
				var graLayAC:ArrayCollection = graGraphicsLayer.graphicProvider as ArrayCollection;
				/*if(graLayAC[0].geometry.hasOwnProperty('rings')){
					if(graLayAC[0].geometry.rings.length>1){
						geom = unionGeoms2(graGraphicsLayer);
					}
					else{
						geom = (graLayAC[0] as Graphic).geometry;
					}
				}
				else{
					
				}*/
				
				if (graLayAC.length > 1)
					geom = unionGeoms2(graGraphicsLayer);
				else if (graLayAC.length == 1)
					geom = graLayAC[0].geometry;//(graLayAC[0] as Graphic).geometry;
				else
					return;
				
				selectedDrawingIcon = null;
				clearSelectionFilter();
				
				if (geom is Polygon && GeometryUtil.polygonSelfIntersecting(geom as Polygon))
				{
					geometryService.([geom], new AsyncResponder(simpResult, null));
					function simpResult(item:Object ,spatialRelat:String):void{
						var simpGeoms:Array = item as Array;
						if(bufferUserGraphic.selected){
							applyBuffer(true);
						}else{
							//esriSpatialRelIndexIntersects 
							queryFeaturesGraphical(simpGeoms[0] as Polygon, "esriSpatialRelIndexIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
						}
					}
				}else{
					//create extent around map point to improve search results
					if (geom.type == Geometry.MAPPOINT && addTolerance.selected)
					{
						geom = createExtentAroundMapPoint(geom as MapPoint, pointSearchTolerance);
					}
					if(bufferUserGraphic.selected){
						applyBuffer(true);
					}else{
						queryFeaturesGraphical(geom, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
					}
				}
				//GeometryUtil.normalizeCentralMeridian([graLayAC[0].geometry],geometryService,  new AsyncResponder(postnormalize, null));				
				/*geometryService.union([graLayAC[0].geometry], new AsyncResponder(postnormalize, null));
				selectedDrawingIcon = null;
				clearSelectionFilter();
				function postnormalize(item:Object ,spatialRelat:String):void{
					
					geom = item as Geometry;
					//clearBuffer();
					if (geom is Polygon && GeometryUtil.polygonSelfIntersecting(geom as Polygon))
					{
						geometryService.simplify([geom], new AsyncResponder(simpResult, null));
						function simpResult(item:Object ,spatialRelat:String):void{
							var simpGeoms:Array = item as Array;
							if(bufferUserGraphic.selected){
								applyBuffer(true);
							}else{
								queryFeaturesGraphical(simpGeoms[0] as Polygon, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
							}
						}
					}else{
						//create extent around map point to improve search results
						if (geom.type == Geometry.MAPPOINT && addTolerance.selected)
						{
							geom = createExtentAroundMapPoint(geom as MapPoint, pointSearchTolerance);
						}
						if(bufferUserGraphic.selected){
							applyBuffer(true);
						}else{
							queryFeaturesGraphical(geom, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
						}
					}
					//graGraphicsLayer.clear();	
				}*/				
			}
			
			private function createExtentAroundMapPoint(centerPoint:MapPoint, tolerance:Number):Extent
			{
				var screenPoint:Point = map.toScreen(centerPoint as MapPoint);
				
				var upperLeftScreenPoint:Point = new Point(screenPoint.x - tolerance, screenPoint.y - tolerance);
				var lowerRightScreenPoint:Point = new Point(screenPoint.x + tolerance, screenPoint.y + tolerance);
				
				var upperLeftMapPoint:MapPoint = map.toMap(upperLeftScreenPoint);
				var lowerRightMapPoint:MapPoint = map.toMap(lowerRightScreenPoint);
				
				return new Extent(upperLeftMapPoint.x, upperLeftMapPoint.y, lowerRightMapPoint.x, lowerRightMapPoint.y, map.spatialReference);
			}
			
			//query features text
			private function queryFeaturesText():void
			{
				if(cboLayerText.text.search("SPECIMEN")> -1 || cboLayerText.text.search("SAMPLE")> -1)
				{
					//do not search until search button is clicked for multiple options
				}
				else
				{
					//hide infowindow if any
					hideInfoWindow();
					var typeQ:String = "layer";
					var i:int = cboLayerText.selectedIndex;
					if(configSearchText[i].layer){
						queryLayer = configSearchText[i].layer;
					}else if(configSearchText[i].table){
						queryLayer = configSearchText[i].table;
						typeQ = "table";
					}
					if (queryLayer && !queryLayer.loaded){
						queryLayer.addEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
						function queryLayer_loadHandler(event:LayerEvent):void
						{
							queryFeaturesText()
						}
						return;
					}
					
					var oidFld:String;
					if(queryLayer.layerDetails)
						oidFld = queryLayer.layerDetails.objectIdField;
					else
						oidFld = queryLayer.tableDetails.objectIdField;
					
					var qFields:Array;
					zoomScale = configSearchText[i].zoomscale;
					zoomPercent = configSearchText[i].zoompercent;
					//queryLayer = (typeQ == "layer") ? configSearchText[i].layer : configSearchText[i].table;
					var j:Number = cboLayerExpr.selectedIndex;
					queryExpr = configSearchText[i].expr[j].expression;
					queryFields = configSearchText[i].fields;
					queryDefExpr = configSearchText[i].defexpr;
					queryLayerRels = configSearchText[i].relates;
					var gfields:XMLList;
					sumField = "";
					gridFields = [];
					
					var qOutFields:Array = [];
					gridHyperFields = [];
					if (queryFields){
						if(queryFields[0].@all == "true")
						{
							//this to dynamically add fields from spatial list
							for (var s2:int =0; s2<fieldsArray.length; s2++)
							{
								if(fieldsArray[s2].gridfield == "true")
								{
									if(fieldsArray[s2].alias == "GMT_DATE_TIME" || fieldsArray[s2].alias=="TRAWL_DEPLOYED_GMT"||fieldsArray[s2].alias=="TRAWL_HAULBACK_START_GMT"||fieldsArray[s2].alias=="GMT_DATE_TIME_END"||fieldsArray[s2].alias=="SHIP_LEAVE_DATE"||fieldsArray[s2].alias=="SHIP_RETURN_DATE"||fieldsArray[s2].alias=="PROCESS_DATE")
									{
										var str:String = fieldsArray[s2].name + "~"+fieldsArray[s2].alias+ "~MM/DD/YYYY L:NN A"+ "~NA"+ "~NA~"+ "true";
									}
									else{
										var str:String = fieldsArray[s2].name + "~"+fieldsArray[s2].alias+ "~NA"+ "~NA"+ "~NA"+ "~NA";
									}
									gridFields.push(str);
									qOutFields.push(fieldsArray[s2].name);
								}
							}
						}
						else{
							gfields = queryFields.field;
							for each (var fieldXML:XML in gfields){
								if (fieldXML.@gridfield[0]){
									if(fieldXML.@gridfield[0]=="true"){
										if(fieldXML.@sum[0] && fieldXML.@sum[0] == "true"){
											if(fieldXML.@sumlabel[0])
												lblSum = fieldXML.@sumlabel[0];
											sumField = fieldXML.@name[0];
										}
										var str:String = fieldXML.@name[0] + "~";
										if(fieldXML.@alias[0]){
											if(fieldXML.@alias[0] == ""){
												str += "NA~";
											}else{
												str += fieldXML.@alias[0] + "~";
											}
										}else{
											str += "NA~";
										}
										if(fieldXML.@dateformat[0]){
											if(fieldXML.@dateformat[0] == ""){
												str += "NA~";
											}else{
												str += fieldXML.@dateformat[0] + "~";
											}
										}else{
											str += "NA~";
										}
										if(fieldXML.@currencyformat[0]){
											if(fieldXML.@currencyformat[0] == ""){
												str += "NA~";
											}else{
												str += fieldXML.@currencyformat[0] + "~";
											}
										}else{
											str += "NA~";
										}
										if(fieldXML.@numberformat[0]){
											if(fieldXML.@numberformat[0] == ""){
												str += "NA~";
											}else{
												str += fieldXML.@numberformat[0] + "~";
											}
										}else{
											str += "NA~";
										}
										if(fieldXML.@useutc[0]){
											if(fieldXML.@useutc[0] == "false"){
												str += "false";
											}else{
												str += "true";
											}
										}else{
											str += "NA";
										}
										gridFields.push(str);
									}
								}
								if (fieldXML.@hyperlinkgridfield[0]){
									if (fieldXML.@hyperlinkgridfield[0]=="true"){
										var str2:String = fieldXML.@name[0] + "~";
										if(fieldXML.@alias[0]){
											if(fieldXML.@alias[0] == ""){
												str2 += "NA~";
											}else{
												str2 += fieldXML.@alias[0] + "~";
											}
										}else{
											str2 += "NA~";
										}
										if(fieldXML.@hyperlinkaliastext[0]){
											if(fieldXML.@hyperlinkaliastext[0] == ""){
												str2 += "NA~";
											}else{
												str2 += fieldXML.@hyperlinkaliastext[0] + "~";
											}
										}else{
											str2 += "NA~";
										}
										if(fieldXML.@linkprefix[0]){
											if(fieldXML.@linkprefix[0] == ""){
												str2 += "NA~";
											}else{
												str2 += fieldXML.@linkprefix[0] + "~";
											}
										}else{
											str2 += "NA~";
										}
										if(fieldXML.@linksuffix[0]){
											if(fieldXML.@linksuffix[0] == ""){
												str2 += "NA";
											}else{
												str2 += fieldXML.@linksuffix[0];
											}
										}else{
											str2 += "NA";
										}
										gridHyperFields.push(str2);
									}
								}
							}	
						}
					}
					
					queryTitleField = configSearchText[i].titlefield;
					if(typeQ == "table"){
						//&&databaseText.text.toUpperCase().search("TRAWL")>-1
						if(queryLayer.tableDetails.name.toUpperCase().search("SPECIMEN") >-1){
							sampleType = "specimen";
						}
						else if(queryLayer.tableDetails.name.toUpperCase().search("SAMPLE") >-1){
							sampleType = "sample";
						}
						else{
							sampleType = "";
						}
					}
					else{
						if(queryLayer.layerDetails.name.toUpperCase().search("SPECIMEN") >-1){
							sampleType = "specimen";
						}
						else if(queryLayer.layerDetails.name.toUpperCase().search("SAMPLE") >-1){
							sampleType = "sample";
						}
						else{
							sampleType = "";
						}
					}
					qLinks = configSearchText[i].links;
					queryMultiImgField = configSearchText[i].multi;
					queryEnableExport = configSearchText[i].enableexport;
					openDataGrid = configSearchText[i].opendg;
					
					var fields:XMLList;
					if ((queryLayer) && (txtSearch.text || cbSearch.text))
					{
						var query:Query = new Query();
						var myPattern:RegExp = /\[value\]/g;
						var expr:String;
						var eVal:String;
						if (txtSearch.visible){
							if(queryExpr != "[value]")//meaning an open SQL expression
								eVal = txtSearch.text.replace("'","''");
							else
								eVal = txtSearch.text;
							expr = queryExpr.replace(myPattern, eVal.toUpperCase()); 
						}else{
							eVal = cbSearch.selectedItem.value.replace("'","''");
							expr = queryExpr.replace(myPattern, eVal); 
						}
						query.where = expr;
						
						//combo of geometry and text search
						if(useSpatial.selected == true && useSpatial.visible == true)
						{
							query.geometry = graGraphicsLayer.graphicProvider[0].geometry;
							//this is to check for features over the Dateline
							if(graGraphicsLayer.graphicProvider[0].geometry is Polyline && Polyline(graGraphicsLayer.graphicProvider[0].geometry).paths.length > 1){
								map.centerAt(Polyline(graGraphicsLayer.graphicProvider[0].geometry).paths[1][1]);
							}
							else if(graGraphicsLayer.graphicProvider[0].geometry is Polygon && Polygon(graGraphicsLayer.graphicProvider[0].geometry).rings.length > 1){
								map.centerAt(Polygon(graGraphicsLayer.graphicProvider[0].geometry).rings[1][1]);
							}
							else if(graGraphicsLayer.graphicProvider[0].geometry is MapPoint){
								map.centerAt(MapPoint(graGraphicsLayer.graphicProvider[0].geometry));
							}
							else {
								map.centerAt(graGraphicsLayer.graphicProvider[0].geometry.extent.center);
							}
							
							map.level = 4;
							querySum.text = "Query "+cboLayerText.text+" where: \n\n" + expr + "\n\n*Text Query in combination with the Spatial Feature on the map."+ "\n\nPercentage (%) in search returns any values with the search value in it.";
						}
						else{
							querySum.text ="Query "+cboLayerText.text+" where: \n\n" + expr + "\n\nNo Map Query Used.\n\nPercentage (%) in search returns any values with the search value in it.";
						}
						
						query.returnGeometry= true;
						queryLayer.useMapTime = false;
						
						//query.timeExtent = map.timeExtent;
						if(qOutFields.length == 0)
						{
							qOutFields.push(fieldsArray[0].name);	
						}
						queryLayer.outFields = qOutFields;
						query.outFields = qOutFields;
						query.outSpatialReference = map.spatialReference;
						if(queryDefExpr != "")
							queryLayer.definitionExpression = queryDefExpr; 
						queryLayer.queryFeatures(query, new AsyncResponder(onResult, onFault, queryFields));
						
						showMessage(loadingLabel, true); 
						showStateResults();   
						// on result
						function onResult(featureSet:FeatureSet, token:XMLList = null):void                
						{   
							if(featureSet.features.length> 25000)
							{
								Alert.show("The search result has more than 25,000 records. Processing these results could take a long time and will only show in the table.  \n\nContinue?", "Alert", 3, wTemplate,continueQueryYesNo);
								
								function continueQueryYesNo(event:CloseEvent):void
								{
									if(event.detail == Alert.YES){
										continueQuery(true);
									}
									else{
										showMessage("Query Cancelled", false);
									}  
								}
							}
							else{
								continueQuery(false);
							}
							
							function continueQuery(largeData:Boolean):void
							{
								
								if(featureSet.geometryType != null && largeData !=true)
								{
									//only clear layers if geometry is being returned
									map.getLayer("EcoDAAT").visible = false;
									unclusterCheck.enabled = true;
								}
								else{
									unclusterCheck.enabled = false;
								}
								try{ 
									var gid:Number = 0;
									for each (var gra:Graphic in featureSet.features){   
										var obj:Object = gra.attributes;
										if(typeQ == "layer"){
											if(!queryLayer.layerDetails.objectIdField){
												obj["oid"] = gid;
												gid ++;
											}else{
												obj["oid"] = gra.attributes[queryLayer.layerDetails.objectIdField];
											}
										}else{
											if(!queryLayer.tableDetails.objectIdField){
												obj["oid"] = gid;
												gid ++;
											}else{
												obj["oid"] = gra.attributes[queryLayer.tableDetails.objectIdField];
											}
										}
									} 
									gridDataProvider = featureSet.attributes;
									resultsFeatureSet = featureSet;
									if(largeData==false)
									{
										if(queryLayerRels && queryLayerRels.length > 0)
											searchResultAC = createSearchResults(featureSet, token, queryLayerRels);
										else
											searchResultAC = createSearchResults(featureSet, token); 
										// share data
										addSharedData(widgetTitle, searchResultAC);
									}
									
									showMessage(selectionLabel + " " + featureSet.features.length, false);
									/* if(featureSet.features.length>0 && sampleType !=""){
										associationOptions = true;
									}
									else{
										associationOptions = false;
									} */
									if(floatorfixed == "fixed"){
										if(!gridFields)
											gridFields = configSearchText[i].gridfields;
										var dgConfig:Object = {
											widgetTitle: widgetTitle,
											csvExportOptionLbl: exp2csvOptLbl,
											txtExportOptionLbl: exp2txtOptLbl,
											ExportButtonLbl: expBtnLbl,
											csvSeperator: csvSep,
											dgFieldAliases: fldAliases,
											csvName: _csvName,
											sumField: sumField,
											labelSum: lblSum,
											hasRelates: (queryLayerRels && queryLayerRels.length > 0),
											dgColumns: gridFields,
											dgHyperColumns: gridHyperFields,
											dProvider: gridDataProvider,
											graphicslayer: graphicsLayer,
											zoomScale: zoomScale,
											zoomPercent: zoomPercent,
											ownerWidget: sWidget,
											Layurl: queryLayer.url,
												lToken: queryLayer.token,
												layerDetails: (queryLayer.layerDetails)?queryLayer.layerDetails:queryLayer.tableDetails,
												enableExport: queryEnableExport,
												widgetInteract: widgetAndGridIteract,
												disableRelateTab: disRelatesInFixed
										}
										var dgconfigArr:ArrayCollection = new ArrayCollection();
										dgconfigArr.addItem(dgConfig);
										addSharedData("configFixedDatagrid", dgconfigArr);
									}
								}
								catch (error:Error){
									showMessage(error.message, false);
								}
							}
						}
						
						//on fault
						function onFault(info:Object, token:Object = null) : void
						{                    
							showMessage(info.toString(), false);         
						}
					} 	
				} 
			}
			
			private function constructQuery(sqlquery:Boolean):String{
				var expr:String = '';
				//Dyanimc date query
				//year
				var yearStringArray:String = "";
				for(var ye:int=0; ye < yearArray.length; ye++){
					if(yearArray[ye].gridfield == "true")
					{
						yearStringArray += yearArray[ye].alias+",";
					}
				}
				if(sqlquery == true){
					expr = "to_char(GMT_DATE_TIME,'YYYY') in ("+yearStringArray.slice( 0, -1 )+")";
				}
				else{
					expr = 'EXTRACT(YEAR FROM "GMT_DATE_TIME") in ('+yearStringArray.slice( 0, -1 )+")";	
				}
				
				
				//month
				var monthStringArray:String = "";
				var mlast:Boolean = false;
				for(var mo:int=0; mo < monthArray.length; mo++){
					if(monthArray[mo].gridfield == "true")
					{
						monthStringArray += monthArray[mo].data+",";
					}
				}
				
				if(sqlquery == true){
					expr += " AND to_char(GMT_DATE_TIME,'MM') in ("+monthStringArray.slice( 0, -1 )+")";
				}
				else{
					expr += ' AND EXTRACT(MONTH FROM "GMT_DATE_TIME") in ('+monthStringArray.slice( 0, -1 )+")";	
				}
				
				//day
				var dayStringArray:String = "";
				if(dayArray[0].gridfield == "true" &&dayArray[1].gridfield == "true")
				{
					//do nothing because all days are selected
				}
				else if(dayArray[0].gridfield == "false" &&dayArray[1].gridfield == "true"){
					if(sqlquery == true){
						expr += " AND to_char(GMT_DATE_TIME,'DD') > 14";
					}
					else{
						expr += ' AND EXTRACT(DAY FROM "GMT_DATE_TIME") > 14';	
					}
				}
				else{
					
					if(sqlquery == true){
						expr += " AND to_char(GMT_DATE_TIME,'DD') < 15";
					}
					else{
						expr += ' AND EXTRACT(DAY FROM "GMT_DATE_TIME") < 15';
					}
				}
				
				//Start of Query text options
				if(microZoopVisible == true)
				{
					//check to make sure haul performance values have been check and select all if not
					if(haulPerText.selectedAll == false && haulPerText.selectedViewsSQL != "noneSelected"){
						expr+= " AND HAUL_PERFORMANCE "+haulPerText.selectedViewsSQL;
					}
					if(cruiseSample.selectedAll == false && cruiseSample.selectedViewsSQL != "noneSelected"){
						expr+= " AND CRUISE "+cruiseSample.selectedViewsSQL;
					}
					if(gearSample.selectedAll == false && gearSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND GEAR_ABBREV "+gearSample.selectedViewsSQL;
					}
					if(meshSample.selectedAll == false && meshSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND MESH "+meshSample.selectedViewsSQL;
					}
					if(netSample.selectedAll == false && netSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND NET "+netSample.selectedViewsSQL;
					}
					if(haulSample.text != ""){
						expr+=" AND HAUL_NAME LIKE '%"+haulSample.text+"%'";
					}
					if(sampleSample.text != ""){
						expr+=" AND HAUL_NAME LIKE '%"+sampleSample.text+"%'";
					}
					if(geolocSample.selectedAll == false && geolocSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND GEOGRAPHIC_AREA "+geolocSample.selectedViewsSQL;
					}
					if(showallDepGear.selected == false){
						expr+=" AND MAX_GEAR_DEPTH > "+minDepGear.value + " AND MAX_GEAR_DEPTH < "+maxDepGear.value;
					}
					if(speciesIch.selectedAll == false && speciesIch.selectedViewsSQL != "noneSelected"){
						expr+=" AND SPECIES_NAME "+speciesIch.selectedViewsSQL;
					}
					return expr;
				}
				else if(cboLayerText.text.search('SPECIMEN') > -1)
				{						
					if(databaseText.selectedLabel.toUpperCase() == "TRAWL")
					{
						//check to make sure haul performance values have been check and select all if not
						expr+= " AND ORIG_DB = 'TRAWL'";
						if(haulPerText.selectedAll == false && haulPerText.selectedViewsSQL != "noneSelected"){
							expr+= " AND HAUL_PERFORMANCE "+haulPerText.selectedViewsSQL;
						}
						if(geolocSample.selectedAll == false && geolocSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND GEOGRAPHIC_AREA "+geolocSample.selectedViewsSQL;
						}
						if(cruiseSample.selectedAll == false&& cruiseSample.selectedViewsSQL != "noneSelected"){
							expr+= " AND CRUISE "+cruiseSample.selectedViewsSQL;
						}
						if(gearSample.selectedAll == false && gearSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND GEAR_ABBREV "+gearSample.selectedViewsSQL;
						}
						if(projectSample.selectedAll == false && projectSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND PROJECT "+projectSample.selectedViewsSQL;
						}
						if(purposeSample.selectedAll == false && purposeSample.selectedViewsSQL != "noneSelected"){
							expr+= " AND PURPOSE "+purposeSample.selectedViewsSQL;
						}
						if(meshSample.selectedAll== false && meshSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND MESH "+meshSample.selectedViewsSQL;
						}
						if(netSample.selectedAll== false && netSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND NET "+netSample.selectedViewsSQL;
						}
						if(haulSample.text != ""){
							expr+=" AND HAUL_ID LIKE '%"+haulSample.text+"%'";
						}
						if(sampleSample.text != ""){
							expr+=" AND FOCI_SAMPLE_ID LIKE '%"+sampleSample.text+"%'";
						}
						if(showallLeng.selected == false){
							expr+=" AND LENGTH_TOTAL > "+minleng.value + " AND LENGTH_TOTAL < "+maxleng.value;
						}
						if(speciesTra.selectedAll== false && speciesTra.selectedViewsSQL != "noneSelected"){
							expr+=" AND SPECIES_NAME "+speciesTra.selectedViewsSQL;
						}
						if(showallDepGear.selected == false){
							expr+=" AND MAX_GEAR_DEPTH > "+minDepGear.value + " AND MAX_GEAR_DEPTH < "+maxDepGear.value;
						}
						if(stationN.text != ""){
							expr+=" AND STATION_NAME LIKE '%"+stationN.text+"%'";
						}
					}
					if(databaseText.selectedLabel == "Ichthyoplankton")
					{
						//check to make sure haul performance values have been check and select all if not
						expr+= " AND ORIG_DB = 'ICHBASE'";
						if(haulPerText.selectedAll == false && haulPerText.selectedViewsSQL != "noneSelected"){
							expr+= " AND HAUL_PERFORMANCE "+haulPerText.selectedViewsSQL;
						}
						if(cruiseSample.selectedAll == false&& cruiseSample.selectedViewsSQL != "noneSelected"){
							expr+= " AND CRUISE "+cruiseSample.selectedViewsSQL;
						}
						if(gearSample.selectedAll == false && gearSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND GEAR_ABBREV "+gearSample.selectedViewsSQL;
						}
						if(projectSample.selectedAll == false && projectSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND PROJECT "+projectSample.selectedViewsSQL;
						}
						if(purposeSample.selectedAll == false && purposeSample.selectedViewsSQL != "noneSelected"){
							expr+= " AND PURPOSE "+purposeSample.selectedViewsSQL;
						}
						if(meshSample.selectedAll== false && meshSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND MESH "+meshSample.selectedViewsSQL;
						}
						if(netSample.selectedAll == false && netSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND NET "+netSample.selectedViewsSQL;
						}
						if(geolocSample.selectedAll == false && geolocSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND GEOGRAPHIC_AREA "+geolocSample.selectedViewsSQL;
						}
						if(haulSample.text != ""){
							expr+=" AND HAUL_ID LIKE '%"+haulSample.text+"%'";
						}
						if(sampleSample.text != ""){
							expr+=" AND FOCI_SAMPLE_ID LIKE '%"+sampleSample.text+"%'";
						}
						if(showallDep.selected == false){
							expr+=" AND BOTTOM_DEPTH > "+minDep.value + " AND BOTTOM_DEPTH< "+maxDep.value;
						}
						if(stageIch.selectedAll == false && stageIch.selectedViewsSQL != "noneSelected"){
							expr+=" AND STAGE_NAME "+stageIch.selectedViewsSQL;
						}
						/* if(showallDispIch.selected == false){
						expr+=" AND VOLUME_DISPLACEMENT > "+minDispIch.value + " AND VOLUME_DISPLACEMENT < "+maxDispIch.value;
						} */
						if(speciesIch.selectedAll == false && speciesIch.selectedViewsSQL != "noneSelected"){
							expr+=" AND SPECIES_NAME "+speciesIch.selectedViewsSQL;
						}
						if(showallDepGear.selected == false){
							expr+=" AND MAX_GEAR_DEPTH > "+minDepGear.value + " AND MAX_GEAR_DEPTH < "+maxDepGear.value;
						}
						if(stationN.text != ""){
							expr+=" AND STATION_NAME LIKE '%"+stationN.text+"%'";
						}
					}
					if(databaseText.selectedLabel == "Zooplankton")
					{
						//check to make sure haul performance values have been check and select all if not
						expr+= " AND ORIG_DB = 'BOB'";
						if(haulPerText.selectedAll == false && haulPerText.selectedViewsSQL != "noneSelected"){
							expr+= " AND HAUL_PERFORMANCE "+haulPerText.selectedViewsSQL;
						}
						if(cruiseSample.selectedAll == false&& cruiseSample.selectedViewsSQL != "noneSelected"){
							expr+= " AND CRUISE "+ cruiseSample.selectedViewsSQL;
						}
						if(gearSample.selectedAll == false && gearSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND GEAR_ABBREV "+gearSample.selectedViewsSQL;
						}
						if(projectSample.selectedAll == false && projectSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND PROJECT "+projectSample.selectedViewsSQL;
						}
						if(purposeSample.selectedAll == false && purposeSample.selectedViewsSQL != "noneSelected"){
							expr+= " AND PURPOSE "+purposeSample.selectedViewsSQL;
						}
						if(meshSample.selectedAll== false && meshSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND MESH "+meshSample.selectedViewsSQL;
						}
						if(netSample.selectedAll == false && netSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND NET "+netSample.selectedViewsSQL;
						}
						if(geolocSample.selectedAll == false && geolocSample.selectedViewsSQL != "noneSelected"){
							expr+=" AND GEOGRAPHIC_AREA "+geolocSample.selectedViewsSQL;
						}
						if(haulSample.text != ""){
							expr+=" AND HAUL_ID LIKE '%"+haulSample.text+"%'";
						}
						if(sampleSample.text != ""){
							expr+=" AND FOCI_SAMPLE_ID LIKE '%"+sampleSample.text+"%'";
						}
						if(showallDep.selected == false){
							expr+=" AND BOTTOM_DEPTH > "+minDep.value + " AND BOTTOM_DEPTH< "+maxDep.value;
						}
						/* if(showallDisp.selected == false){
						expr+=" AND VOLUME_DISPLACEMENT > "+minDisp.value + " AND VOLUME_DISPLACEMENT < "+maxDisp.value;
						} */
						if(stageBob.selectedAll == false && stageBob.selectedViewsSQL != "noneSelected"){
							expr+=" AND STAGEID "+stageBob.selectedViewsSQL;
						}
						if(sizeBob.selectedAll == false && sizeBob.selectedViewsSQL != "noneSelected"){
							expr+=" AND SPECIMEN_SIZE "+sizeBob.selectedViewsSQL;
						}
						if(typeBob.selectedAll == false && typeBob.selectedViewsSQL != "noneSelected"){
							expr+=" AND ZOOP_PROTOCOL "+typeBob.selectedViewsSQL;
						}
						if(taxaBob.selectedAll == false && taxaBob.selectedViewsSQL != "noneSelected"){
							expr+=" AND TAXON_NAME "+taxaBob.selectedViewsSQL;
						}
						if(sexText.selectedLabel != "ALL"){
							expr+=" AND SEX_NAME = '"+sexText.selectedLabel+"'";
						}
						if(showallDepGear.selected == false){
							expr+=" AND MAX_GEAR_DEPTH > "+minDepGear.value + " AND MAX_GEAR_DEPTH < "+maxDepGear.value;
						}
						if(stationN.text != ""){
							expr+=" AND STATION_NAME LIKE '%"+stationN.text+"%'";
						}
					}
					return expr;
				}
				else if(cboLayerText.text.search('SAMPLE') > -1)
				{
					//check to make sure haul performance values have been check and select all if not
					expr+= " AND SAMPLE_TYPE IN ( "+databaseTextSamp.selectedItem.data+")";
					if(haulPerText.selectedAll == false && haulPerText.selectedViewsSQL != "noneSelected"){
						expr+= " AND HAUL_PERFORMANCE "+haulPerText.selectedViewsSQL;
					}
					if(cruiseSample.selectedAll == false&& cruiseSample.selectedViewsSQL != "noneSelected"){
						expr+= " AND CRUISE "+ cruiseSample.selectedViewsSQL;
					}
					if(gearSample.selectedAll == false && gearSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND GEAR_ABBREV "+gearSample.selectedViewsSQL;
					}
					if(projectSample.selectedAll == false && projectSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND PROJECT "+projectSample.selectedViewsSQL;
					}
					if(purposeSample.selectedAll == false && purposeSample.selectedViewsSQL != "noneSelected"){
						expr+= " AND PURPOSE "+purposeSample.selectedViewsSQL;
					}
					if(geolocSample.selectedAll == false && geolocSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND GEOGRAPHIC_AREA "+geolocSample.selectedViewsSQL;
					}
					if(meshSample.selectedAll== false && meshSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND MESH "+meshSample.selectedViewsSQL;
					}
					if(netSample.selectedAll == false && netSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND NET "+netSample.selectedViewsSQL;
					}
					if(haulSample.text != ""){
						expr+=" AND HAUL_ID LIKE '%"+haulSample.text+"%'";
					}
					if(sampleSample.text != ""){
						expr+=" AND FOCI_SAMPLE_ID LIKE '%"+sampleSample.text+"%'";
					}
					if(showallDep.selected == false){
						expr+=" AND BOTTOM_DEPTH > "+minDep.value + " AND BOTTOM_DEPTH< "+maxDep.value;
					}
					if(showallDepGear.selected == false){
						expr+=" AND MAX_GEAR_DEPTH > "+minDepGear.value + " AND MAX_GEAR_DEPTH < "+maxDepGear.value;
					}
					if(stationN.text != ""){
						expr+=" AND STATION_NAME LIKE '%"+stationN.text+"%'";
					}
					return expr;
				}
				else if(cboLayerText.text.search('HAUL') > -1)
				{
					//check to make sure haul performance values have been check and select all if not
					if(haulPerText.selectedAll == false && haulPerText.selectedViewsSQL != "noneSelected"){
						expr+= " AND HAUL_PERFORMANCE "+haulPerText.selectedViewsSQL;
					}
					if(cruiseSample.selectedAll == false&& cruiseSample.selectedViewsSQL != "noneSelected"){
						expr+= " AND CRUISE "+ cruiseSample.selectedViewsSQL;
					}
					if(projectSample.selectedAll == false && projectSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND PROJECT "+projectSample.selectedViewsSQL;
					}
					if(purposeSample.selectedAll == false && purposeSample.selectedViewsSQL != "noneSelected"){
						expr+= " AND PURPOSE "+purposeSample.selectedViewsSQL;
					}
					if(gearSample.selectedAll == false && gearSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND GEAR_NAME "+gearSample.selectedViewsSQL;
					}
					if(geolocSample.selectedAll == false && geolocSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND GEOGRAPHIC_AREA "+geolocSample.selectedViewsSQL;
					}
					if(meshSample.selectedAll== false && meshSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND MESH "+meshSample.selectedViewsSQL;
					}
					if(netSample.selectedAll == false && netSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND NET "+netSample.selectedViewsSQL;
					}
					if(haulSample.text != ""){
						expr+=" AND HAUL_ID LIKE '%"+haulSample.text+"%'";
					}
					if(sampleSample.text != ""){
						expr+=" AND FOCI_SAMPLE_ID LIKE '%"+sampleSample.text+"%'";
					}
					if(stationN.text != ""){
						expr+=" AND STATION_NAME LIKE '%"+stationN.text+"%'";
					}
					return expr;
				}
				else if(cboLayerText.text.search('SEACAT')>-1||cboLayerText.text.search('CTDB')>-1||cboLayerText.text.search('CHLOROPHYLL')>-1||cboLayerText.text.search('NUTRIENT')>-1){
					if(cruiseSample.selectedAll == false&& cruiseSample.selectedViewsSQL != "noneSelected"){
						expr+= " AND CRUISE "+ cruiseSample.selectedViewsSQL;
					}
					if(gearSample.selectedAll == false && gearSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND GEAR_NAME "+gearSample.selectedViewsSQL;
					}
					if(geolocSample.selectedAll == false && geolocSample.selectedViewsSQL != "noneSelected"){
						expr+=" AND GEOGRAPHIC_AREA "+geolocSample.selectedViewsSQL;
					}
					if(haulSample.text != ""){
						expr+=" AND HAUL_ID LIKE '%"+haulSample.text+"%'";
					}
					if(sampleSample.text != ""){
						expr+=" AND HAUL_ID LIKE '%"+sampleSample.text+"%'";
					}
					if(stationN.text != ""){
						expr+=" AND HAUL_ID LIKE '%"+stationN.text+"%'";
					}
					return expr;
				}
				else{
					return expr;
				}
//				else{
//					if (txtSearch.visible){
//						if(queryExpr != "[value]")//meaning an open SQL expression
//							eVal = txtSearch.text.replace("'","''");
//						else
//							eVal = txtSearch.text;
//						expr = queryExpr.replace(myPattern, eVal.toUpperCase()); 
//					}else{
//						eVal = cbSearch.selectedItem.value.replace("'","''");
//						expr = queryExpr.replace(myPattern, eVal); 
//					}
//					
//				}
			}
			//query features text from button click
			private function queryFeaturesText2():void
			{
				//hide infowindow if any
				hideInfoWindow();
				var typeQ:String = "layer";
				var i:int = cboLayerText.selectedIndex;
				if(configSearchText[i].layer){
					queryLayer = configSearchText[i].layer;
				}else if(configSearchText[i].table){
					queryLayer = configSearchText[i].table;
					typeQ = "table";
				}
				if (queryLayer && !queryLayer.loaded){
					queryLayer.addEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
					function queryLayer_loadHandler(event:LayerEvent):void
					{
						queryFeaturesText()
					}
					return;
				}
				
				var oidFld:String;
				if(queryLayer.layerDetails)
					oidFld = queryLayer.layerDetails.objectIdField;
				else
					oidFld = queryLayer.tableDetails.objectIdField;
				
				var qFields:Array;
				zoomScale = configSearchText[i].zoomscale;
				zoomPercent = configSearchText[i].zoompercent;
				//queryLayer = (typeQ == "layer") ? configSearchText[i].layer : configSearchText[i].table;
				var j:Number = cboLayerExpr.selectedIndex;
				queryExpr = configSearchText[i].expr[j].expression;
				queryFields = configSearchText[i].fields;
				queryDefExpr = configSearchText[i].defexpr;
				queryLayerRels = configSearchText[i].relates;
				var gfields:XMLList;
				sumField = "";
				gridFields = [];
				
				var qOutFields:Array = [];
				gridHyperFields = [];
				if (queryFields){
					if(queryFields[0].@all == "true")
					{
						//this to dynamically add fields from spatial list
						for (var s2:int =0; s2<dg.dataProvider.length; s2++)
						{
							if(dg.dataProvider[s2].gridfield == "true")
							{
								if(dg.dataProvider[s2].alias == "GMT_DATE_TIME" || dg.dataProvider[s2].alias=="TRAWL_DEPLOYED_GMT"||dg.dataProvider[s2].alias=="TRAWL_HAULBACK_START_GMT"||dg.dataProvider[s2].alias=="GMT_DATE_TIME_END"||dg.dataProvider[s2].alias=="SHIP_LEAVE_DATE"||dg.dataProvider[s2].alias=="SHIP_RETURN_DATE"||dg.dataProvider[s2].alias=="PROCESS_DATE")
								{
									var str:String = dg.dataProvider[s2].name + "~"+dg.dataProvider[s2].alias+ "~MM/DD/YYYY L:NN A"+ "~NA"+ "~NA~"+ "true";
								}
								else{
									var str:String = dg.dataProvider[s2].name + "~"+dg.dataProvider[s2].alias+ "~NA"+ "~NA"+ "~NA"+ "~NA";
								}
								gridFields.push(str);
								qOutFields.push(dg.dataProvider[s2].name);
							}
						}
					}
					else{
						gfields = queryFields.field;
						for each (var fieldXML:XML in gfields){
							if (fieldXML.@gridfield[0]){
								if(fieldXML.@gridfield[0]=="true"){
									if(fieldXML.@sum[0] && fieldXML.@sum[0] == "true"){
										if(fieldXML.@sumlabel[0])
											lblSum = fieldXML.@sumlabel[0];
										sumField = fieldXML.@name[0];
									}
									var str:String = fieldXML.@name[0] + "~";
									if(fieldXML.@alias[0]){
										if(fieldXML.@alias[0] == ""){
											str += "NA~";
										}else{
											str += fieldXML.@alias[0] + "~";
										}
									}else{
										str += "NA~";
									}
									if(fieldXML.@dateformat[0]){
										if(fieldXML.@dateformat[0] == ""){
											str += "NA~";
										}else{
											str += fieldXML.@dateformat[0] + "~";
										}
									}else{
										str += "NA~";
									}
									if(fieldXML.@currencyformat[0]){
										if(fieldXML.@currencyformat[0] == ""){
											str += "NA~";
										}else{
											str += fieldXML.@currencyformat[0] + "~";
										}
									}else{
										str += "NA~";
									}
									if(fieldXML.@numberformat[0]){
										if(fieldXML.@numberformat[0] == ""){
											str += "NA~";
										}else{
											str += fieldXML.@numberformat[0] + "~";
										}
									}else{
										str += "NA~";
									}
									if(fieldXML.@useutc[0]){
										if(fieldXML.@useutc[0] == "false"){
											str += "false";
										}else{
											str += "true";
										}
									}else{
										str += "NA";
									}
									gridFields.push(str);
								}
							}
							if (fieldXML.@hyperlinkgridfield[0]){
								if (fieldXML.@hyperlinkgridfield[0]=="true"){
									var str2:String = fieldXML.@name[0] + "~";
									if(fieldXML.@alias[0]){
										if(fieldXML.@alias[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@alias[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@hyperlinkaliastext[0]){
										if(fieldXML.@hyperlinkaliastext[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@hyperlinkaliastext[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@linkprefix[0]){
										if(fieldXML.@linkprefix[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@linkprefix[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@linksuffix[0]){
										if(fieldXML.@linksuffix[0] == ""){
											str2 += "NA";
										}else{
											str2 += fieldXML.@linksuffix[0];
										}
									}else{
										str2 += "NA";
									}
									gridHyperFields.push(str2);
								}
							}
						}	
					}
				}
				
				queryTitleField = configSearchText[i].titlefield;
				if(typeQ == "table"){
					//&&databaseText.text.toUpperCase().search("TRAWL")>-1
					if(queryLayer.tableDetails.name.toUpperCase().search("SPECIMEN") >-1){
						sampleType = "specimen";
					}
					else if(queryLayer.tableDetails.name.toUpperCase().search("SAMPLE") >-1){
						sampleType = "sample";
					}
					else{
						sampleType = "";
					}
				}
				else{
					if(queryLayer.layerDetails.name.toUpperCase().search("SPECIMEN") >-1){
						sampleType = "specimen";
					}
					else if(queryLayer.layerDetails.name.toUpperCase().search("SAMPLE") >-1){
						sampleType = "sample";
					}
					else{
						sampleType = "";
					}
				}
				
				qLinks = configSearchText[i].links;
				queryMultiImgField = configSearchText[i].multi;
				queryEnableExport = configSearchText[i].enableexport;
				openDataGrid = configSearchText[i].opendg;
				
				var fields:XMLList;
				if ((queryLayer) && (txtSearch.text || cbSearch.text))
				{
					var query:Query = new Query();
					var myPattern:RegExp = /\[value\]/g;
					var expr:String;
					var eVal:String;
															
					expr= constructQuery(false);
					
					
					//combo of geometry and text search
					if(useSpatial.selected == true && useSpatial.visible == true)
					{
						query.geometry = graGraphicsLayer.graphicProvider[0].geometry;
						if(graGraphicsLayer.graphicProvider[0].geometry is Polyline && Polyline(graGraphicsLayer.graphicProvider[0].geometry).paths.length > 1){
							map.centerAt(Polyline(graGraphicsLayer.graphicProvider[0].geometry).paths[1][1]);
						}
						else if(graGraphicsLayer.graphicProvider[0].geometry is Polygon && Polygon(graGraphicsLayer.graphicProvider[0].geometry).rings.length > 1){
							map.centerAt(Polygon(graGraphicsLayer.graphicProvider[0].geometry).rings[1][1]);
						}
						else if(graGraphicsLayer.graphicProvider[0].geometry is MapPoint){
							map.centerAt(MapPoint(graGraphicsLayer.graphicProvider[0].geometry));
						}
						else {
							map.centerAt(graGraphicsLayer.graphicProvider[0].geometry.extent.center);
						}
						map.level = 4;
						querySum.text = "Query "+cboLayerText.text+" where: \n\n" + expr + "\n\n*Text Query in combination with the Spatial Feature on the map."+ "\n\nPercentage (%) in search returns any values with the search value in it.";
					}
					else{
						querySum.text ="Query "+cboLayerText.text+" where: \n\n" + expr + "\n\nNo Map Query Used.\n\nPercentage (%) in search returns any values with the search value in it.";
					}
					
					query.returnGeometry= true;
					query.outSpatialReference = map.spatialReference;
					/* if(microZoopVisible == true)
					{
					query.returnGeometry= false;
					}
					else{
					query.returnGeometry= true;
					query.outSpatialReference = map.spatialReference;
					} */
					queryLayer.useMapTime = false;
					
					query.where = expr;
					//query.timeExtent = map.timeExtent;
					if(qOutFields.length == 0)
					{
						qOutFields.push(fieldsArray[0].name);	
					}
					queryLayer.outFields = qOutFields;
					query.outFields = qOutFields;
					
					//order by fields
					//query.orderByFields = ['SPECIES_NAME ASC, TAXON_NAME'];
					if(tokenUse != ""){
						queryLayer.token = tokenUse;
					}
					if(queryDefExpr != "")
						queryLayer.definitionExpression = queryDefExpr; 
					
					queryLayer.queryFeatures(query, new AsyncResponder(onResult, onFault, queryFields));
					
					showMessage(loadingLabel, true); 
					showStateResults(); 
					  
					// on result
					function onResult(featureSet:FeatureSet, token:XMLList = null):void                
					{   
						if(featureSet.features.length> 25000)
						{
							Alert.show("The search result has more than 25,000 records. Processing these results could take a long time and will only show in the table form.  \n\nContinue?", "Alert", 3, wTemplate,continueQueryYesNo);
							
							function continueQueryYesNo(event:CloseEvent):void
							{
								if(event.detail == Alert.YES){
									continueQuery(true);
								}
								else{
									showMessage("Query Cancelled", false);
								}  
							}
						}
						else{
							continueQuery(false);
						}
						
						function continueQuery(largeData:Boolean):void
						{
							if(featureSet.geometryType != null && largeData !=true)
							{
								//only clear layers if geometry is being returned
								map.getLayer("EcoDAAT").visible = false;
								unclusterCheck.enabled = true;
							}
							else{
								unclusterCheck.enabled = false;
							}
							try{ 
								var gid:Number = 0;
								
								for each (var gra:Graphic in featureSet.features){   
									var obj:Object = gra.attributes;
									if(typeQ == "layer"){
										if(!queryLayer.layerDetails.objectIdField){
											obj["oid"] = gid;
											gid ++;
										}else{
											obj["oid"] = gra.attributes[queryLayer.layerDetails.objectIdField];
										}
									}else{
										if(!queryLayer.tableDetails.objectIdField){
											obj["oid"] = gid;
											gid ++;
										}else{
											obj["oid"] = gra.attributes[queryLayer.tableDetails.objectIdField];
										}
									}
								}  
								var timeField:Boolean = false;
								for each (var fld:Object in dg.dataProvider){
									if(fld.name == 'GMT_DATE_TIME'&&fld.gridfield == "true"){
										timeField = true;
									}
								}
								if(timeField == true){
									var newFieldArray:ArrayCollection = new ArrayCollection;
									for (var f2:int =0; f2<featureSet.attributes.length; f2++){
										var featureObj:Object = featureSet.attributes[f2];
										var featureDate:Date = new Date(featureObj.GMT_DATE_TIME);
										featureObj['YEAR'] = featureDate.fullYear;
										featureObj['MONTH'] = featureDate.month+1;
										featureObj['DAY'] = featureDate.date;
										newFieldArray.addItem(featureObj);
									}
									gridDataProvider =newFieldArray;
									gridFields.push("YEAR~YEAR~NA~NA~NA~NA");
									gridFields.push("MONTH~MONTH~NA~NA~NA~NA");
									gridFields.push("DAY~DAY~NA~NA~NA~NA");
									gridHyperFields['MONTH'] = 'MONTH';
									gridHyperFields['YEAR'] = 'YEAR';
									gridHyperFields['DAY'] = 'DAY';
								}
								else{
									gridDataProvider = featureSet.attributes;
								}
								resultsFeatureSet = featureSet;
								if(largeData == false){
									if(queryLayerRels && queryLayerRels.length > 0)
										searchResultAC = createSearchResults(featureSet, token, queryLayerRels);
									else
										searchResultAC = createSearchResults(featureSet, token); 
									// share data
									addSharedData(widgetTitle, searchResultAC);
								}
								
								if(floatorfixed == "fixed"){
									if(!gridFields)
										gridFields = configSearchText[i].gridfields;
									var dgConfig:Object = {
										widgetTitle: widgetTitle,
										csvExportOptionLbl: exp2csvOptLbl,
										txtExportOptionLbl: exp2txtOptLbl,
										ExportButtonLbl: expBtnLbl,
										csvSeperator: csvSep,
										dgFieldAliases: fldAliases,
										csvName: _csvName,
										sumField: sumField,
										labelSum: lblSum,
										hasRelates: (queryLayerRels && queryLayerRels.length > 0),
										dgColumns: gridFields,
										dgHyperColumns: gridHyperFields,
										dProvider: gridDataProvider,
										graphicslayer: graphicsLayer,
										zoomScale: zoomScale,
										zoomPercent: zoomPercent,
										ownerWidget: sWidget,
										Layurl: queryLayer.url,
											lToken: queryLayer.token,
											layerDetails: (queryLayer.layerDetails)?queryLayer.layerDetails:queryLayer.tableDetails,
											enableExport: queryEnableExport,
											widgetInteract: widgetAndGridIteract,
											disableRelateTab: disRelatesInFixed
									}
									var dgconfigArr:ArrayCollection = new ArrayCollection();
									dgconfigArr.addItem(dgConfig);
									
									showMessage(selectionLabel + " " + featureSet.features.length, false);
									addSharedData("configFixedDatagrid", dgconfigArr);
								}
							}
							catch (error:Error){
								if(String(error.message).search("executed for longer")>-1){
									showMessage(selectionLabel + " " + featureSet.features.length, false);
								}
								else{
									showMessage(error.message, false);
								}
							}
						}
					}
					
					//on fault
					function onFault(info:Object, token:Object = null) : void
					{                    
						showMessage(info.toString(), false);         
					}
				} 
			}	
			
			private function selectRelationshipData():void
			{
				showMessage(loadingLabel, true); 
				showStateResults();
				//set up relationship for layer
				var relateQuery:RelationshipQuery = new RelationshipQuery;
				//specimen relate link
				if(cboLayerText.selectedLabel.search("DIET")>-1){
					relateQuery.relationshipId =5;
				}
				else if(cboLayerText.selectedLabel.search("SUBSPECIMEN")>-1){
					relateQuery.relationshipId =6;
				}
				//sample relate link
				else if(cboLayerText.selectedLabel.search("SPECIMEN")>-1){
					relateQuery.relationshipId =0;
				}
				else if(cboLayerText.selectedLabel.search("NUTRIENT")>-1){
					relateQuery.relationshipId =4;
				}
				else if(cboLayerText.selectedLabel.search("CHLOR")>-1){
					relateQuery.relationshipId =3;
				}
				else if(cboLayerText.selectedLabel.search("CTDB")>-1){
					relateQuery.relationshipId =2;
				}
				else if(cboLayerText.selectedLabel.search("SEACAT")>-1){
					relateQuery.relationshipId =1;
				}
								
				var fLay:FeatureLayer = queryLayer;
				var queryObj:Object = graphicsLayer.graphicProvider;
				var objIDArray:Array = new Array;
				
				for (var qObjectId:int =0; qObjectId<queryObj.length; qObjectId++){
					objIDArray.push(queryObj[qObjectId].attributes.oid);
				}
				if(objIDArray.length>1800){
					querySum.text = "Query: "+ cboLayerText.selectedLabel+" related to sample or specimen search. \n\nThere is a large number of records to match.  \n\nNote: PLEASE TRY TO FILTER QUERY FURTHER.";
				}
				else{
					//parse fields 
					var fieldNames:Array = new Array;
					var qOutFields:Array = new Array;
					for (var s2:int =0; s2<dg.dataProvider.length; s2++)
					{
						if(dg.dataProvider[s2].gridfield == "true")
						{
							if(dg.dataProvider[s2].alias == "GMT_DATE_TIME" || dg.dataProvider[s2].alias=="TRAWL_DEPLOYED_GMT"||dg.dataProvider[s2].alias=="TRAWL_HAULBACK_START_GMT"||dg.dataProvider[s2].alias=="GMT_DATE_TIME_END"||dg.dataProvider[s2].alias=="SHIP_LEAVE_DATE"||dg.dataProvider[s2].alias=="SHIP_RETURN_DATE"||dg.dataProvider[s2].alias=="PROCESS_DATE")
							{
								var str:String = dg.dataProvider[s2].name + "~"+dg.dataProvider[s2].alias+ "~MM/DD/YYYY L:NN A"+ "~NA"+ "~NA~"+ "true";
							}
							else{
								var str:String = dg.dataProvider[s2].name + "~"+dg.dataProvider[s2].alias+ "~NA"+ "~NA"+ "~NA"+ "~NA";
							}
							fieldNames.push(str);
							//qOutFields.push(fieldsArray[s2].name);
						}
					}
					//this doesn't work for all attributes
					/* if(qOutFields.length == 0)
					{
					qOutFields.push(fieldsArray[0].name);	
					} */
					
					relateQuery.objectIds = objIDArray;
					relateQuery.outFields = ['*'];
					fLay.queryRelatedFeatures(relateQuery, new AsyncResponder(onResult, onFault));
					function onResult(relatedRecords:Object, token:XMLList = null):void
					{
						// get related records for the first feature
						var attributes:ArrayCollection = new ArrayCollection;
						for each (var i:FeatureSet in relatedRecords)
						{
							for each (var j:Graphic in i.features)
							{
								attributes.addItem(j.attributes);
							}
						}
						if (attributes.length>0)
						{
							// share data with datagrid
							showMessage(selectionLabel + " " + attributes.length, false);
							var x:int = cboLayerText.selectedIndex;
							if(floatorfixed == "fixed"){
								//if(!gridFields)
								//gridFields = configSearchText[x].gridfields;
								var dgConfig:Object = {
									widgetTitle: widgetTitle,
									csvExportOptionLbl: exp2csvOptLbl,
									txtExportOptionLbl: exp2txtOptLbl,
									ExportButtonLbl: expBtnLbl,
									csvSeperator: csvSep,
									dgFieldAliases: fldAliases,
									csvName: _csvName,
									sumField: sumField,
									labelSum: lblSum,
									hasRelates: (queryLayerRels && queryLayerRels.length > 0),
									dgColumns: fieldNames,
									dgHyperColumns: gridHyperFields,
									dProvider: attributes,
									graphicslayer: null,
									zoomScale: zoomScale,
									zoomPercent: zoomPercent,
									ownerWidget: sWidget,
									Layurl: queryLayer.url,
										lToken: queryLayer.token,
										layerDetails: (queryLayer.layerDetails)?queryLayer.layerDetails:queryLayer.tableDetails,
										enableExport: queryEnableExport,
										widgetInteract: widgetAndGridIteract,
										disableRelateTab: disRelatesInFixed
								}
								var dgconfigArr:ArrayCollection = new ArrayCollection();
								dgconfigArr.addItem(dgConfig);
								addSharedData("configFixedDatagrid", dgconfigArr);
							}
						}
						else
						{
							showMessage("No related records were found", false); 
						}
					}
					function onFault(info:Object, token:Object = null):void
					{
						showMessage(info.toString(), false); 
					}
					querySum.text = "Query: "+ cboLayerText.selectedLabel+" related to sample/specimen search. \n\nNote: THIS QUERY MAY TAKE A WHLE.";
				}
			}
			
			private function generateCatch():void
			{
				var go:Boolean = true;
				var inputData:Object = {};
				var gptoolurl:String = '';				
				var speciesList:Array = [];
				
				cboLayerText.selectedIndex = 2;
				inputData['InputQueryHaul'] = constructQuery(false);
				
				if(databaseText.selectedLabel == 'Zooplankton'){
					
					gptoolurl =catchzerotoolGPbob;
					
					if(stageBob.selectedItems.length>0){
						inputData['stage'] = stageBob.selectedItems[0].name;
					}
					else{
						Alert.show("Please Select one stage for query.", "Query Problem");
						go =false;
					}
					if(taxaBob.selectedItems.length>0){
						
						for (var s2:int =0; s2<taxaBob.selectedItems.length; s2++)
						{
							speciesList.push(taxaBob.selectedItems[s2].alias);
						}
						inputData['Taxa_List'] = speciesList;
						inputData['InputSpeciesQuery'] = constructQuery(false)+ " and taxon_name = '%taxa%'";
					}
					else{
						Alert.show("Please Select Species for query.", "Query Problem");
						go =false;
					}
				}
				else if(databaseText.selectedLabel == 'Ichthyoplankton'){
					gptoolurl =catchzerotoolGP;
					if(stageIch.selectedItems.length>0){
						inputData['stage'] = stageIch.selectedItems[0].alias;
					}
					else{
						Alert.show("Please Select one stage for query.", "Query Problem");
						go =false;
					}
					if(speciesIch.selectedItems.length>0){
						for (var s2:int =0; s2<speciesIch.selectedItems.length; s2++)
						{
							speciesList.push(speciesIch.selectedItems[s2].alias);
						}
						inputData['Species_List'] = speciesList;
						inputData['InputSpeciesQuery'] = constructQuery(false)+ " and species_name = '%specie%'";
					}
					else{
						Alert.show("Please Select Species for query.", "Query Problem");
						go =false;
					}
				}
				else if(databaseText.selectedLabel == 'TRAWL'){
					gptoolurl =catchzerotoolGP;
					//no trawl stage
					inputData['stage'] = 'TRAWL';
					
					if(speciesTra.selectedItems.length>0){
						for (var s2:int =0; s2<speciesTra.selectedItems.length; s2++)
						{
							speciesList.push(speciesTra.selectedItems[s2].alias);
						}
						inputData['Species_List'] = speciesList;
						inputData['InputSpeciesQuery'] = constructQuery(false)+ " and species_name = '%specie%'";
					}
					else{
						Alert.show("Please Select Species for query.", "Query Problem");
						go =false;
					}
				}
								
				
				if(go == true){
										
					cboLayerText.selectedIndex = 1;
					var gps:Geoprocessor = new Geoprocessor(gptoolurl);
					if(tokenUse !="")
					{
						gps.token = tokenUse;
					}
					
					gps.showBusyCursor = true;
					gps.addEventListener(GeoprocessorEvent.JOB_COMPLETE,getResultDataComplete);
					gps.addEventListener(FaultEvent.FAULT,gp_faultHandler);
					//gps.addEventListener(GeoprocessorEvent.STATUS_UPDATE,getstatusGP);
					gps.submitJob(inputData);
					
					dataproc_status.includeInLayout = true;
					dataproc_status.visible = true;
					showError("\nThe Catch with Zero tool is currently running.  \nThis could take a couple of minutes to run.  \n\nAn excel file will be downloaded to your computer when done.  \nYou can continue querying data while the tool is running.", "Tool is Running");
					
					//queryFeaturesText2();
					
					function getResultDataComplete(event:GeoprocessorEvent):void
					{
						if(event.jobInfo.jobStatus == 'esriJobFailed'){
							showError("\nThere was an error. \nTry running with different settings or query.", "Error");
						}
						else{
							gps.addEventListener(GeoprocessorEvent.GET_RESULT_DATA_COMPLETE, onGetResult);
							
							gps.getResultData(event.jobInfo.jobId, 'output_catch_zero'); 
							
							function onGetResult(event : GeoprocessorEvent):void
							{ 
								var url:URLRequest = new URLRequest(event.parameterValue.value.url);
								navigateToURL(url, "_blank");
								//var fileReference:FileReference = new FileReference();
								//fileReference.download(url);
							} 
						}
						dataproc_status.includeInLayout = false;
						dataproc_status.visible = false;
					}
				}
			}
			
			private function generateTrawlLength():void{
				var gps:Geoprocessor = new Geoprocessor(trawllengthGP);
				var inputData:Object = {};
				if(databaseText.selectedLabel != "TRAWL"){
					Alert.show("Please Select Trawl Specimen Type for query.", "Query Problem");
				}
				else{
					inputData['Input_Query_Filter'] = constructQuery(false);
					
					if(tokenUse !="")
					{
						gps.token = tokenUse;
					}
					
					gps.showBusyCursor = true;
					gps.addEventListener(GeoprocessorEvent.JOB_COMPLETE,getResultDataComplete);
					//gps.addEventListener(GeoprocessorEvent.STATUS_UPDATE,getstatusGP);
					gps.addEventListener(FaultEvent.FAULT,gp_faultHandler);
					gps.submitJob(inputData);
					showError("The Trawl Length analysis tool is currently running.  \nThis could take a couple of minutes to run.  \n\nFour(4) excel file will be downloaded to your computer when done. \n\nStandard Length \nTotal Length \nFork Length \nLegth at Sea \n\nYou can continue querying data while the tool is running.", "Tool is Running");
					
					dataproc_status.includeInLayout = true;
					dataproc_status.visible = true;
					
					function getResultDataComplete(event:GeoprocessorEvent):void
					{
						if(event.jobInfo.jobStatus == 'esriJobFailed'){
							showError("\nThere was an error. \nTry running with different settings or query.", "Error");
						}
						else{
							gps.addEventListener(GeoprocessorEvent.GET_RESULT_DATA_COMPLETE, onGetResult);
							
							gps.getResultData(event.jobInfo.jobId, 'totallength_freq_trawl_xls');
							gps.getResultData(event.jobInfo.jobId, 'lengthsea_freq_trawl_xls');
							gps.getResultData(event.jobInfo.jobId, 'forklength_freq_trawl_xls');
							gps.getResultData(event.jobInfo.jobId, 'standardlength_freq_trawl_xls');
							
							function onGetResult(event : GeoprocessorEvent):void
							{ 
								var url:URLRequest = new URLRequest(event.parameterValue.value.url);
								navigateToURL(url, "_blank");
							}	
						}
						dataproc_status.includeInLayout = false;
						dataproc_status.visible = false;
					}
				}			
			}
			private function generateIchLength():void{
				var gps:Geoprocessor = new Geoprocessor(ichlengthGP);
				var inputData:Object = {};
				if(cboLayerText.selectedIndex != 3){
					Alert.show("Please Select SubSpecimen type Ichthyoplankton for query.", "Query Problem");
				}
				else{
					inputData['Input_Query_Filter'] = constructQuery(false);
					
					if(tokenUse !="")
					{
						gps.token = tokenUse;
					}
					
					gps.showBusyCursor = true;
					gps.addEventListener(GeoprocessorEvent.JOB_COMPLETE,getResultDataComplete);
					//gps.addEventListener(GeoprocessorEvent.STATUS_UPDATE,getstatusGP);
					gps.addEventListener(FaultEvent.FAULT,gp_faultHandler);
					gps.submitJob(inputData);
					dataproc_status.includeInLayout = true;
					dataproc_status.visible = true;
					showError("\nThe Ichthyoplankton length analysis tool is currently running.  \nThis could take a couple of minutes to run.  \n\nAn excel file will be downloaded to your computer when done.  \nYou can continue querying data while the tool is running.", "Tool is Running");
					
					function getResultDataComplete(event:GeoprocessorEvent):void
					{
						if(event.jobInfo.jobStatus == 'esriJobFailed'){
							showError("\nThere was an error. \nTry running with different settings or query.", "Error");
						}
						else{
							gps.addEventListener(GeoprocessorEvent.GET_RESULT_DATA_COMPLETE, onGetResult);
							
							gps.getResultData(event.jobInfo.jobId, 'Output_Excel_FIle'); 
							
							function onGetResult(event : GeoprocessorEvent):void
							{ 
								var url:URLRequest = new URLRequest(event.parameterValue.value.url);
								navigateToURL(url, "_blank");
							}	
						}
					}
					dataproc_status.includeInLayout = false;
					dataproc_status.visible = false;
				}
			}
			private function generateIchAbundance():void{
				var gps:Geoprocessor = new Geoprocessor(ichabundanceGP);
				var inputData:Object = {};
				if(cboLayerText.selectedIndex != 3){
					Alert.show("Please Select SubSpecimen type Ichthyoplankton for query.", "Query Problem");
				}
				else{
					inputData['Input_Query '] = constructQuery(false);
					
					if(tokenUse !="")
					{
						gps.token = tokenUse;
					}
					
					gps.showBusyCursor = true;
					//gps.addEventListener(GeoprocessorEvent.STATUS_UPDATE,getstatusGP);
					
					gps.addEventListener(GeoprocessorEvent.JOB_COMPLETE,getResultDataComplete);
					gps.addEventListener(FaultEvent.FAULT,gp_faultHandler);
					gps.submitJob(inputData);
					showError("\nThe Ichthyoplankton Abundance tool is currently running.  \nThis could take a couple of minutes to run.  \nAn excel file will be downloaded to your computer when done.  \nYou can continue querying data while the tool is running.", "Tool is Running");
					dataproc_status.includeInLayout = true;
					dataproc_status.visible = true;
					
					function getResultDataComplete(event:GeoprocessorEvent):void
					{
						if(event.jobInfo.jobStatus == 'esriJobFailed'){
							showError("\nThere was an error. \nTry running with different settings or query.", "Error");
						}
						else{
							gps.addEventListener(GeoprocessorEvent.GET_RESULT_DATA_COMPLETE, onGetResult);
							
							gps.getResultData(event.jobInfo.jobId, 'Output_Table'); 
							
							function onGetResult(event : GeoprocessorEvent):void
							{ 
								var url:URLRequest = new URLRequest(event.parameterValue.value.url);
								navigateToURL(url, "_blank");
							}	
						}
						dataproc_status.includeInLayout = false;
						dataproc_status.visible = false;
					}
				}
			}
			private function gp_faultHandler(event:FaultEvent):void
			{
				var msg:String = "\n\n\n" + event.fault.faultString;
				showError(msg);
			}
			
			private function getstatusGP(event:Event):void
			{
				//var msg:String = "\n\n\n";
				//showError(msg);
			}
			
			//query features graphical
			private function queryFeaturesGraphical(geom:Geometry, querySpatialRel:String, layerConfig:Object):void
			{
				//hide infowindow if any
				typeQ = "layer";
				hideInfoWindow();
				var qFields:Array;
				queryLayer = layerConfig.layer;
				var oidFld:String = queryLayer.layerDetails.objectIdField;
				queryGeom = geom;
				zoomScale = layerConfig.zoomscale;
				zoomPercent = layerConfig.zoompercent;
				queryFields = layerConfig.fields;
				queryExpr = layerConfig.expr;
				var gfields:XMLList;
				gridFields = [];
				var gridFieldsOut:Array = [];
				gridHyperFields = [];
				sumField = "";
				if (queryFields){
					if(queryFields[0].@all == "true")
					{
						//this to dynamically add fields from spatial list
						for (var s2:int =0; s2<fieldsArray2.length; s2++)
						{
							if(fieldsArray2[s2].gridfield == "true")
							{
								if(fieldsArray2[s2].alias == "GMT_DATE_TIME" || fieldsArray2[s2].alias=="TRAWL_DEPLOYED_GMT"||fieldsArray2[s2].alias=="TRAWL_HAULBACK_START_GMT"||fieldsArray2[s2].alias=="GMT_DATE_TIME_END"||fieldsArray2[s2].alias=="SHIP_LEAVE_DATE"||fieldsArray2[s2].alias=="SHIP_RETURN_DATE"||fieldsArray2[s2].alias=="PROCESS_DATE")
								{
									var str:String = fieldsArray2[s2].name + "~"+fieldsArray2[s2].alias+ "~MM/DD/YYYY L:NN A"+ "~NA"+ "~NA~"+ "true";
								}
								else{
									var str:String = fieldsArray2[s2].name + "~"+fieldsArray2[s2].alias+ "~NA"+ "~NA"+ "~NA"+ "~NA";
								}
								
								gridFields.push(str);
								gridFieldsOut.push(fieldsArray2[s2].name);
							}
						}
					}
					else{
						gfields = queryFields.field;
						for each (var fieldXML:XML in gfields){
							if (fieldXML.@gridfield[0]){
								if(fieldXML.@gridfield[0]=="true"){
									if(fieldXML.@sum[0] && fieldXML.@sum[0] == "true"){
										if(fieldXML.@sumlabel[0])
											lblSum = fieldXML.@sumlabel[0];
										sumField = fieldXML.@name[0];
									}
									var str:String = fieldXML.@name[0] + "~";
									if(fieldXML.@alias[0]){
										if(fieldXML.@alias[0] == ""){
											str += "NA~";
										}else{
											str += fieldXML.@alias[0] + "~";
										}
									}else{
										str += "NA~";
									}
									if(fieldXML.@dateformat[0]){
										if(fieldXML.@dateformat[0] == ""){
											str += "NA~";
										}else{
											str += fieldXML.@dateformat[0] + "~";
										}
									}else{
										str += "NA~";
									}
									if(fieldXML.@currencyformat[0]){
										if(fieldXML.@currencyformat[0] == ""){
											str += "NA~";
										}else{
											str += fieldXML.@currencyformat[0] + "~";
										}
									}else{
										str += "NA~";
									}
									if(fieldXML.@numberformat[0]){
										if(fieldXML.@numberformat[0] == ""){
											str += "NA~";
										}else{
											str += fieldXML.@numberformat[0] + "~";
										}
									}else{
										str += "NA~";
									}
									if(fieldXML.@useutc[0]){
										if(fieldXML.@useutc[0] == "false"){
											str += "false";
										}else{
											str += "true";
										}
									}else{
										str += "NA";
									}
									gridFields.push(str);
								}
							}
							if (fieldXML.@hyperlinkgridfield[0]){
								if (fieldXML.@hyperlinkgridfield[0]=="true"){
									var str2:String = fieldXML.@name[0] + "~";
									if(fieldXML.@alias[0]){
										if(fieldXML.@alias[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@alias[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@hyperlinkaliastext[0]){
										if(fieldXML.@hyperlinkaliastext[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@hyperlinkaliastext[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@linkprefix[0]){
										if(fieldXML.@linkprefix[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@linkprefix[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@linksuffix[0]){
										if(fieldXML.@linksuffix[0] == ""){
											str2 += "NA";
										}else{
											str2 += fieldXML.@linksuffix[0];
										}
									}else{
										str2 += "NA";
									}
									gridHyperFields.push(str2);
								}
							}
						}
					}
				}
				queryTitleField = layerConfig.titlefield;
				if(typeQ == "table"){
					//&&databaseText.text.search("TRAWL")>-1
					if(queryLayer.tableDetails.name.search("SPECIMEN") >-1){
						sampleType = "specimen";
					}
					else if(queryLayer.tableDetails.name.search("SAMPLE") >-1){
						sampleType = "sample";
					}
					else{
						sampleType = "";
					}
				}
				else{
					if(queryLayer.layerDetails.name.search("SPECIMEN") >-1){
						sampleType = "specimen";
					}
					else if(queryLayer.layerDetails.name.search("SAMPLE") >-1){
						sampleType = "sample";
					}
					else{
						sampleType = "";
					}
				}
				qLinks = layerConfig.links;
				//queryLinkIconIsField = layerConfig.linkiconisfield;
				queryMultiImgField = layerConfig.multi;
				queryExprForSpatRel = layerConfig.useforspatial;
				queryEnableExport = layerConfig.enableexport;
				queryDefExpr = layerConfig.defexpr;
				openDataGrid = layerConfig.opendg;
				queryLayerRels = layerConfig.relates;
				
				var fields:XMLList;
				if (queryLayer){
					var query:Query = new Query();
					query.geometry = queryGeom;
					if(queryGeom is Polyline && Polyline(queryGeom).paths.length > 1){
						map.centerAt(Polyline(queryGeom).paths[1][1]);
					}
					else if(queryGeom is Polygon && Polygon(queryGeom).rings.length > 1){
						map.centerAt(Polygon(queryGeom).rings[1][1]);
					}
					else if(queryGeom is MapPoint){
						map.centerAt(MapPoint(queryGeom));
					}
					else {
						map.centerAt(queryGeom.extent.center);
					}
					map.level = 4;
					query.returnGeometry = true;
					query.timeExtent = map.timeExtent;
					querySum.text = "Query " + cboLayerGraphical.text +" \n\nSpatial Search:  Geometry location criteria is seen on map.\n\nZoom in closer to see more detail.";
					query.spatialRelationship = querySpatialRel;
					query.outSpatialReference = map.spatialReference;
					if(gridFieldsOut.length ==0)
					{
						gridFieldsOut.push(fieldsArray2[0].name);	
					}
					query.outFields = gridFieldsOut;
					queryLayer.outFields = gridFieldsOut;
									
					if(queryDefExpr != "")
						queryLayer.definitionExpression = queryDefExpr;
					queryLayer.queryFeatures(query, new AsyncResponder(onResult, onFault, queryFields));
					showMessage(loadingLabel, true); 
					showStateResults();   
					// on result
					function onResult(featureSet:FeatureSet, token:XMLList = null):void
					{   
						if(featureSet.features.length> 25000)
						{
							Alert.show("The search result has more than 25,000 records. Processing these results could take a long time and will only show in the table form.  \n\nContinue?", "Alert", 3, wTemplate,continueQueryYesNo);
							
							function continueQueryYesNo(event:CloseEvent):void
							{
								if(event.detail == Alert.YES){
									continueQuery(true);
								}
								else{
									showMessage("Query Cancelled", false);
								}  
							}
						}
						else{
							continueQuery(false);
						}
						
						function continueQuery(largeData:Boolean):void
						{
							if(featureSet.geometryType != null && largeData !=true)
							{
								//only clear layers if geometry is being returned
								map.getLayer("EcoDAAT").visible = false;
								unclusterCheck.enabled = true;
							}
							else{
								unclusterCheck.enabled = false;
							}
							try{
								var gid:Number = 0;
								for each (var gra:Graphic in featureSet.features){ 
									//if(graGraphicsLayer.contains(gra.geometry as MapPoint)){
										
										var obj:Object = gra.attributes;
										if(!queryLayer.layerDetails.objectIdField){
											obj["oid"] = gid;
											gid ++;
										}else{
											obj["oid"] = gra.attributes[queryLayer.layerDetails.objectIdField];
										}
								} 
								gridDataProvider = featureSet.attributes;
								resultsFeatureSet = featureSet;
								//only show if the data is below threshold
								if(largeData ==false){
									if(queryLayerRels && queryLayerRels.length > 0)
										searchResultAC = createSearchResults(featureSet, token, queryLayerRels);
									else
										searchResultAC = createSearchResults(featureSet, token); 
									addSharedData(widgetTitle, searchResultAC);
								}
								showMessage(selectionLabel + " " + featureSet.features.length, false);
								
								/* if(featureSet.features.length>0 && sampleType !=""){
									associationOptions = true;
								}
								else{
									associationOptions = false;
								} */
								if(floatorfixed == "fixed"){
									var dgConfig:Object = {
										widgetTitle: widgetTitle,
										csvExportOptionLbl: exp2csvOptLbl,
										txtExportOptionLbl: exp2txtOptLbl,
										ExportButtonLbl: expBtnLbl,
										csvSeperator: csvSep,
										dgFieldAliases: fldAliases,
										csvName: _csvName,
										sumField: sumField,
										labelSum: lblSum,
										hasRelates: (queryLayerRels && queryLayerRels.length > 0),
										dgColumns: gridFields,
										dgHyperColumns: gridHyperFields,
										dProvider: gridDataProvider,
										graphicslayer: graphicsLayer,
										zoomScale: zoomScale,
										zoomPercent: zoomPercent,
										ownerWidget: sWidget,
										Layurl: queryLayer.url,
											lToken: queryLayer.token,
											layerDetails: queryLayer.layerDetails,
											enableExport: queryEnableExport,
											widgetInteract: widgetAndGridIteract,
											disableRelateTab: disRelatesInFixed
									}
									var dgconfigArr:ArrayCollection = new ArrayCollection();
									dgconfigArr.addItem(dgConfig);
									addSharedData("configFixedDatagrid", dgconfigArr);
								}
							}
							catch (error:Error){
								showMessage(error.message, false);
							}
						}	
					}
					
					//on fault
					function onFault(info:Object, token:Object = null) : void
					{                    
						showMessage(info.toString(), false);         
					}
				}
			}
			
			private function unionGeoms(featureSet:FeatureSet):Geometry
			{
				var graphic:Graphic;
				var retGeom:Geometry;
				var mPoint:Multipoint = new Multipoint(null);
				var mPoly:Polygon = new Polygon(null);
				var mPolyL:Polyline = new Polyline(null);
				var rType:String;
				for each (graphic in featureSet.features)
				{
					if(graphic.geometry.type == "esriGeometryPoint")
					{
						mPoint.addPoint(graphic.geometry as MapPoint);
						rType = "point";
					}
					
					if(graphic.geometry.type == "esriGeometryMultipoint")
					{
						var mp:Multipoint = graphic.geometry as Multipoint
						var pnts:MapPoint;
						for (var p:int=0;p < mp.points.length; p++)
						{
							mPoint.addPoint(mp.points[p]);
						}
						rType = "point";
					}
					
					if(graphic.geometry.type == "esriGeometryPolygon")
					{
						var poly:Polygon = graphic.geometry as Polygon;
						for (var i2:int = poly.rings.length - 1; i2 >= 0; i2--)
						{
							var ringArray:Array = [];
							for (var j1:int = 0; j1 < poly.rings[i2].length; j1++)
							{
								var mp2:MapPoint = poly.getPoint(i2,j1) as MapPoint;
								mp2.spatialReference = poly.spatialReference;
								ringArray.push(mp2);
							}
							mPoly.addRing(ringArray);
						}
						rType = "poly";
						mPoly.spatialReference = poly.spatialReference;
					}
					
					if(graphic.geometry.type == "esriGeometryPolyline")
					{
						var polyl:Polyline = graphic.geometry as Polyline;
						for(var l:int=polyl.paths.length-1; l >= 0; l--)
						{
							var pathArray:Array = [];
							for (var j2:int = 0; j2 < polyl.paths[l].length; j2++)
							{
								var mp3:MapPoint = polyl.getPoint(l,j2) as MapPoint;
								mp3.spatialReference = polyl.spatialReference;
								pathArray.push(mp3);
							}
							mPolyL.addPath(pathArray);
						}
						rType = "line";
					}
					
					if(graphic.geometry.type == "esriGeometryEnvelope")
					{
						var ext:Extent = graphic.geometry as Extent;
						var pA:Array = [];
						pA.push(new MapPoint(ext.xmin,ext.ymin,ext.spatialReference));
						pA.push(new MapPoint(ext.xmin,ext.ymax,ext.spatialReference));
						pA.push(new MapPoint(ext.xmax,ext.ymax,ext.spatialReference));
						pA.push(new MapPoint(ext.xmax,ext.ymin,ext.spatialReference));
						pA.push(new MapPoint(ext.xmin,ext.ymin,ext.spatialReference));
						mPoly.addRing(pA);
						rType = "poly";
					}
				}
				var graphic2:Graphic = new Graphic();
				var sfs:SimpleFillSymbol = new SimpleFillSymbol();
				sfs.color = 0x0000FF;
				sfs.alpha = 0.2;
				var sms:SimpleMarkerSymbol = new SimpleMarkerSymbol();
				sms.color = 0x0000FF;
				sms.style = SimpleMarkerSymbol.STYLE_CIRCLE;
				sms.size = 8;
				sfs.alpha = 0.4;
				var sls:SimpleLineSymbol = new SimpleLineSymbol();
				sls.color = 0x0000FF;
				sls.style = SimpleLineSymbol.STYLE_SOLID;
				sls.width = 1;
				sls.alpha = 0.4;
				
				switch(rType){
					case "point":
					{
						graphic2.geometry = mPoint;
						graphic2.symbol = sms;
						graphicsLayerBuffer.clear();
						graphicsLayerBuffer.add(graphic2);
						retGeom = mPoint;
						break;
					}
					case "poly":
					{
						graphic2.geometry = mPoly;
						graphic2.symbol = sfs;
						graphicsLayerBuffer.clear();
						graphicsLayerBuffer.add(graphic2);
						retGeom = mPoly;
						break;
					}
					case "line":
					{
						graphic2.geometry = mPolyL;
						graphic2.symbol = sls;
						graphicsLayerBuffer.clear();
						graphicsLayerBuffer.add(graphic2);
						retGeom = mPolyL;
						break;
					}
				}
				return retGeom;
			}
			
			private function applyBuffer(isGraphicalBufferOp:Boolean=false):void
			{
				var graLayAC:ArrayCollection;
				if(isGraphicalBufferOp)
					graLayAC = graGraphicsLayer.graphicProvider as ArrayCollection;
				else
					graLayAC = graphicsLayer.graphicProvider as ArrayCollection;
				
				if (graLayAC.length > 0){
					geomArr = [];
					var buffUnit:Number;
					
					if(isGraphicalBufferOp){
						for each (var graphic:Graphic in graGraphicsLayer.graphicProvider)
						{
							geomArr.push(graphic.geometry);
						}
						buffUnit = GeometryService[configBufferUnits[cboGraBufferUnit.selectedIndex].name];
						bufferGeometries(geomArr,sReff,[textGraInputBuffer.text],buffUnit,isGraphicalBufferOp);
					}else{
						for each (var graphic2:Graphic in graphicsLayer.graphicProvider)
						{
							geomArr.push(graphic2.geometry);
						}
						//buffUnit = GeometryService[configBufferUnits[cboBufferUnit.selectedIndex].name];
						//bufferGeometries(geomArr,sReff,[textInputBuffer.text],buffUnit,isGraphicalBufferOp);
					}
				} else {
					showStateResults();
					showMessage("There is no result to buffer, please make a graphical or text search first.",false);
				}
			}
			
			private function bufferGeometries(geomArr:Array, sr:SpatialReference, dist:Array, unit:Number, isGraphicalBufferOp:Boolean=false):void
			{
				if (geomArr)
				{
					var bufferParameters:BufferParameters = new BufferParameters();
					var resultEvent:Polygon = new Polygon;
					bufferParameters.geometries = geomArr;
					bufferParameters.bufferSpatialReference = sr;
					bufferParameters.unit = unit;
					bufferParameters.distances = dist;
					bufferParameters.unionResults = true;
					geometryService.addEventListener(GeometryServiceEvent.BUFFER_COMPLETE, bufferCompleteHandler);
					geometryService.buffer(bufferParameters);
					
					function bufferCompleteHandler(event:GeometryServiceEvent):void
					{
						geometryService.removeEventListener(GeometryServiceEvent.BUFFER_COMPLETE, bufferCompleteHandler);
						resultEvent = event.result[0];
						try
						{
							var graphic:Graphic = new Graphic();
							var sfs:SimpleFillSymbol = new SimpleFillSymbol();
							if(isGraphicalBufferOp){
								sfs.color = cpGraBufferColor.selectedColor;//0x0000FF;
								sfs.alpha = hsGraBufferAlpha.value;//0.2;
							}
							graphic.geometry = resultEvent;
							graphic.symbol = sfs;
							
							graphicsLayerBuffer.clear();
							graphicsLayerBuffer.add(graphic);
							if(isGraphicalBufferOp)
								queryFeaturesGraphical(resultEvent, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
						}
						catch (error:Error)
						{
							showMessage(error.message, false);
						}
					}					
				}
			}
			
			//create Search Results
			private function createSearchResults(featureSet:FeatureSet, queryFields:XMLList, queryRelates:Array = null):ArrayCollection
			{
				graphicsLayer.clear();
				if(queryLayer.layerDetails)
					layerDetails = queryLayer.layerDetails;
				else
					layerDetails = queryLayer.tableDetails;
				var fields:XMLList = queryFields ? queryFields.field : null;
				
				var result:ArrayCollection = new ArrayCollection();
				if (!queryTitleField)
					queryTitleField = featureSet.displayFieldName;

				for each (var graphic:Graphic in featureSet.features){
					var value:String = "";
					var title:String = "";
					var content:String = "";
					var multi:String = "";
					fldAliases = featureSet.fieldAliases;
					lyrQLinks = [];
					
					//Go through the fields looking for the links
					var excludeLinkinResults:ArrayCollection = new ArrayCollection();
					var obj:Object = graphic.attributes;
					for (var a:int = 0; a < qLinks.length; a++){
						var link:String = "";
						var linkicon:String = "";
						var alias:String = "";
						if (queryFields && queryFields[0].@all[0] == "true"){
							if (layerDetails.fields){
								for each (var field:Field in layerDetails.fields){
									var val:String;
									try{	        	    		       
										val = obj[field.name] ? String(obj[field.name]) : "";
									} catch (error: Error){
										val = "";
									}
									if (field.name.toUpperCase() == qLinks[a].field.toUpperCase() || field.name.toUpperCase() == qLinks[a].icon.toUpperCase()){
										if (field.name.toUpperCase() == qLinks[a].field.toUpperCase()){
											if(qLinks[a].alias)
												alias = qLinks[a].alias;
											//Add the field name if the link field is to be included in the
											//results as well as used for a link.
											if(!qLinks[a].inc)
												excludeLinkinResults.addItem(qLinks[a].field.toUpperCase());
											//concatenate
											if(val != "" && val != "Null" && val != "unavailable")
												link = qLinks[a].pre + val + qLinks[a].suf;
											if( qLinks[a].iconpre != "" || qLinks[a].iconsuf != "")
												linkicon = qLinks[a].iconpre + qLinks[a].iconsuf;
											if(field.name.toUpperCase() == qLinks[a].icon.toUpperCase()){
												//concatenate
												if(val != "" && val != "Null" && val != "unavailable"){
													linkicon = qLinks[a].iconpre + val + qLinks[a].iconsuf;
												}else if(qLinks[a].iconpre != "" || qLinks[a].iconsuf != ""){
													linkicon = qLinks[a].iconpre + val + qLinks[a].iconsuf;
												}
											}
										}
									}
								}
							}else{
								for (var fieldName:String in graphic.attributes){
									var val2:String;
									try{	        	    		       
										val2 = obj[fieldName] ? String(obj[fieldName]) : "";
									} catch (error: Error){
										val2 = "";
									}
									if (fieldName.toUpperCase() == qLinks[a].field.toUpperCase() || fieldName.toUpperCase() == qLinks[a].icon.toUpperCase()){
										if (fieldName.toUpperCase() == qLinks[a].field.toUpperCase()){
											if(qLinks[a].alias)
												alias = qLinks[a].alias;
											//Add the field name if the link field is to be included in the
											//results as well as used for a link.
											if(!qLinks[a].inc)
												excludeLinkinResults.addItem(qLinks[a].field.toUpperCase());
											//concatenate
											if(val2 != "" && val2 != "Null" && val2 != "unavailable")
												link = qLinks[a].pre + val2 + qLinks[a].suf;
											if( qLinks[a].iconpre != "" || qLinks[a].iconsuf != "")
												linkicon = qLinks[a].iconpre + qLinks[a].iconsuf;
											if(field.name.toUpperCase() == qLinks[a].icon.toUpperCase()){
												//concatenate
												if(val2 != "" && val2 != "Null" && val2 != "unavailable"){
													linkicon = qLinks[a].iconpre + val2 + qLinks[a].iconsuf;
												}else if(qLinks[a].iconpre != "" || qLinks[a].iconsuf != ""){
													linkicon = qLinks[a].iconpre + val2 + qLinks[a].iconsuf;
												}
											}
										}
									}
								}
							}
						}else{
							for each (var fieldXML:XML in fields){ // display the fields in the same order as specified
								var val3:String;
								try{	        	    		       
									val3 = obj[fieldXML.@name[0]] ? String(obj[fieldXML.@name[0]]) : "";
								} catch (error: Error){
									val3 = "";
								}
								if (fieldXML.@name[0].toUpperCase() == qLinks[a].field.toUpperCase() || fieldXML.@name[0].toUpperCase() == qLinks[a].icon.toUpperCase()){
									if (fieldXML.@name[0].toUpperCase() == qLinks[a].field.toUpperCase()){
										if(qLinks[a].alias)
											alias = qLinks[a].alias;
										//Add the field name if the link field is to be included in the
										//results as well as used for a link.
										if(!qLinks[a].inc)
											excludeLinkinResults.addItem(qLinks[a].field.toUpperCase());
										//concatenate
										if(val3 != "" && val3 != "Null" && val3 != "unavailable")
											link = qLinks[a].pre + val3 + qLinks[a].suf;
										if( qLinks[a].iconpre != "" || qLinks[a].iconsuf != "")
											linkicon = qLinks[a].iconpre + qLinks[a].iconsuf;
										if(fieldXML.@name[0].toUpperCase() == qLinks[a].icon.toUpperCase()){
											//concatenate
											if(val3 != "" && val3 != "Null" && val3 != "unavailable"){
												linkicon = qLinks[a].iconpre + val3 + qLinks[a].iconsuf;
											}else if(qLinks[a].iconpre != "" || qLinks[a].iconsuf != ""){
												linkicon = qLinks[a].iconpre + val3 + qLinks[a].iconsuf;
											}
										}
									}
								}
							}
						}
						//Handle a link that is not associated with a field
						if(qLinks[a].field == "" && (qLinks[a].pre != "" || qLinks[a].suf != ""))
							link = qLinks[a].pre + qLinks[a].suf;
						
						var lObj:Object ={
							link: link,
							icon: linkicon,
							alias: alias
						}
						lyrQLinks.push(lObj);
					}
					
					if (queryFields && queryFields[0].@all[0] == "true"){
						if (layerDetails.fields){
							for each (var field2:Field in layerDetails.fields){
								if (field2.name in graphic.attributes){
									displayFields(field2.name, getFieldXML(field2.name, fields), field2);	
								}
							}
						}else{
							for (var fieldName2:String in graphic.attributes){
								displayFields(fieldName2, getFieldXML(fieldName2, fields), null);
							}
						}
					}else{
						for each (var fieldXML2:XML in fields){ // display the fields in the same order as specified
							if (fieldXML2.@name[0] in graphic.attributes)
								displayFields(fieldXML2.@name[0], fieldXML2, getField(fieldXML2.@name[0]));
						}
					}
					
					function displayFields(fieldName:String, fieldXML:XML, field:Field):void
					{
						value = (graphic.attributes[fieldName] != null) ? String(graphic.attributes[fieldName]) : "";						
						if (value){
							var isDateField:Boolean;
							var dateFormat:String;
							var numFormat:String;
							var curFormat:String;
							var useUTC:Boolean;
							if (fieldXML){
								numFormat = fieldXML.@numberformat[0];
								curFormat = fieldXML.@currencyformat[0];
								useUTC = fieldXML.@useutc[0] == "true";
								dateFormat = fieldXML.@dateformat[0];
								if (dateFormat)
									isDateField = true;
							}
							if (!isDateField && field)
								isDateField = field.type == Field.TYPE_DATE;
							if (isDateField){
								var dateMS:Number = Number(value);
								if (!isNaN(dateMS))
									value = msToDate(dateMS, dateFormat, useUTC);
							}
							
							if(numFormat){
								var args:Array = numFormat.split("|");
								if(args[0])
									numFormatter.precision = args[0];
								if(args[1]){
									numFormatter.thousandsSeparatorFrom = args[1];
									numFormatter.thousandsSeparatorTo = args[1];
								}else{
									numFormatter.useThousandsSeparator = false;
								}
								if(args[2]){
									numFormatter.decimalSeparatorFrom = args[2];
									numFormatter.decimalSeparatorTo = args[2];
								}
								value = numFormatter.format(value);
							}
							
							if(curFormat){
								var args2:Array = curFormat.split("|");
								if(args2[0])
									currFormatter.currencySymbol = args2[0];
								if(args2[1])
									currFormatter.precision = args2[1];
								if(args2[2]){
									currFormatter.thousandsSeparatorFrom = args2[2];
									currFormatter.thousandsSeparatorTo = args2[2];
								}else{
									currFormatter.useThousandsSeparator = false;
								}
								if(args2[3]){
									currFormatter.decimalSeparatorFrom = args2[3];
									currFormatter.decimalSeparatorTo = args2[3];
								}
								value = currFormatter.format(value);
							}
							if(layerDetails && field){
								var typeID:String = layerDetails.typeIdField ? graphic.attributes[fieldName] : null;
								if (layerDetails.typeIdField && fieldName.toUpperCase() == layerDetails.typeIdField.toUpperCase()){
									// replace value with feature type name
									var featureType:FeatureType = getFeatureType(typeID);
									if (featureType && featureType.name)
										value = featureType.name;
								}else{
									// replace value with coded value name if one exists
									var codedValue:CodedValue = getCodedValue(fieldName, value, typeID);
									if (codedValue)
										value = codedValue.name;
								}
							}
						}						
						if (fieldName.toUpperCase() == queryTitleField.toUpperCase()){
							title = value;
							if (!title)
								title = widgetTitle;
						}
						if (fieldName.toUpperCase() == queryMultiImgField.toUpperCase())
							multi = value;
						if (fieldName.toUpperCase() != "SHAPE_LENGTH" 
							&& fieldName.toUpperCase() != "SHAPE_AREA"
							&& fieldName.toUpperCase() != queryMultiImgField.toUpperCase() 
							&& fieldName.toUpperCase() != queryTitleField.toUpperCase()){
							if(fieldXML){
								if(fieldXML.@gridfieldonly[0] && fieldXML.@gridfieldonly[0] == "true" || 
									fieldXML.@hyperlinkgridfieldonly[0] && fieldXML.@hyperlinkgridfieldonly[0] == "true"){
								 //ignore
								}else{
									if(!excludeLinkinResults.contains(fieldName.toUpperCase())){
										if (fieldXML && fieldXML.@alias[0])
											content += "<b>" + fieldXML.@alias[0];
										else
											content += "<b>" + featureSet.fieldAliases[fieldName];
										content += ": </b><i>" + value + "</i><br>";
									}
								}
							}else{
								if(fieldName != "oid"){
									if(!excludeLinkinResults.contains(fieldName.toUpperCase())){
										content += "<b>" + featureSet.fieldAliases[fieldName];
										content += ": </b><i>" + value + "</i><br>";
									}
								}
							} 
						}
					}						
					graphic.checkForMouseListeners = false;
					
					var searchResult:SearchResult = new SearchResult();
					searchResult.title = title;
					searchResult.content = content.substr(0,content.length - 4);
					if(graphic.geometry)
						searchResult.point = getGeomCenter(graphic);
					searchResult.links = lyrQLinks;
					searchResult.relateicon = relateIcon ? relateIcon : null;
					if(graphic.geometry)
						searchResult.geometry = graphic.geometry;
					searchResult.multi = multi ? multi :null;
					if(graphic.geometry){
						searchResult.zoomscale = zoomScale;
						searchResult.zoompercent = zoomPercent;
					}
					if(!queryLayer.layerDetails){
						if(!queryLayer.tableDetails.objectIdField){
							searchResult.oid = graphic.attributes["oid"];
						}else{
							searchResult.oid = graphic.attributes[queryLayer.tableDetails.objectIdField];
						}
					}else{
						if(!queryLayer.layerDetails.objectIdField){
							searchResult.oid = graphic.attributes["oid"];
						}else{
							searchResult.oid = graphic.attributes[queryLayer.layerDetails.objectIdField];
						}
					}
					searchResult.graphic = graphic;
					searchResult.relates = queryRelates;
					if(queryRelates && queryRelates.length == 1)
						searchResult.relateicon = queryRelates[0].icon;
					searchResult.relatetooltip = relateToolTip;
					
					if(graphic.geometry){
						switch (graphic.geometry.type){
							case Geometry.MAPPOINT:{
								graphic.symbol = searchResult.symbol = resultMarkerSymbol;
								break;
							}
							case Geometry.POLYLINE:{
								graphic.symbol = searchResult.symbol = resultLineSymbol;
								break;
							}
							case Geometry.POLYGON:{
								graphic.symbol = searchResult.symbol = resultFillSymbol;
								break;
							}
						}
					}else{
						searchResult.symbol = resultSATSymbol;
					}
					graphic.attributes = searchResult;
					result.addItem(searchResult);
				
					if (searchResult.point && !isNaN(searchResult.point.x) && !isNaN(searchResult.point.y)){
						
						// make sure it is a valid point
						graphic.addEventListener(MouseEvent.CLICK,pointClickHandler);
//						var myTextFormat:TextFormat = new TextFormat();
//						myTextFormat.font = "Verdana";
//						myTextFormat.size = 15;
//						myTextFormat.bold = true;
//						myTextFormat.italic = false;
//						myTextFormat.underline = false;

						var labelgraphic:Graphic = new Graphic();
						labelgraphic.geometry =  WebMercatorUtil.geographicToWebMercator(graphic.geometry);
						var textSymbol:TextSymbol = new TextSymbol();
						textSymbol.background = false;
						textSymbol.backgroundColor = 0xFFFFFF;
						textSymbol.border = false;
						textSymbol.borderColor = 0x000000;
						textSymbol.color = 0x000000;
						textSymbol.placement = "above";
						textSymbol.text = graphic.attributes.title;
						//textSymbol.textFormat = myTextFormat;
						textSymbol.xoffset = 10;
						textSymbol.yoffset = 0;
						labelgraphic.symbol = textSymbol; 
						
						
						graphic.geometry = WebMercatorUtil.geographicToWebMercator(graphic.geometry);
						
						//webMercatorUtils.
						graphicsLayer.add(labelgraphic);
						
						graphicsLayer.add(graphic);
						// infowWindowRenderer on each graphic
						var infoWindowRenderer:ClassFactory = new ClassFactory(PopUpRenderer);
						infoWindowRenderer.properties = {popUpInfo:configurePopUpInfo(lyrQLinks)};
						graphic.infoWindowRenderer = infoWindowRenderer;
					}
						
				}
				graphicsLayer.visible = true;
				graphicsLayer.refresh();
				return result;
			}
			
			private function getFieldXML(fieldName:String, fields:XMLList):XML
			{
				var result:XML;
				
				for each (var fieldXML:XML in fields){
					if (fieldName == fieldXML.@name[0]){
						result = fieldXML;
						break;
					}
				}
				return result;
			}
			
			private function getField(fieldName:String):Field
			{
				var result:Field;
				
				if (queryLayer && queryLayer.layerDetails){
					for each (var field:Field in queryLayer.layerDetails.fields){
						if (fieldName == field.name){
							result = field;
							break;
						}
					}
				}
				if(queryLayer && queryLayer.tableDetails){
					for each (var field2:Field in queryLayer.tableDetails.fields){
						if (fieldName == field2.name){
							result = field2;
							break;
						}
					}
				}
				return result;
			}
			
			private function getFeatureType(typeID:String):FeatureType
			{
				var result:FeatureType;
				var featureType:FeatureType;
				
				if (queryLayer && queryLayer.layerDetails){
					for each (featureType in queryLayer.layerDetails.types){
						if (typeID == featureType.id){
							result = featureType;
							break;
						}
					}
				}
				if(queryLayer && queryLayer.tableDetails){
					for each (featureType in queryLayer.tableDetails.types){
						if (typeID == featureType.id){
							result = featureType;
							break;
						}
					}
				}
				return result;
			}
			
			private function msToDate(ms:Number, dateFormat:String, useUTC:Boolean):String
			{
				var date:Date = new Date(ms);
				if (date.milliseconds == 999) // workaround for REST bug
					date.milliseconds++;
				if (useUTC)
					date.minutes += date.timezoneOffset;
				
				if (dateFormat){
					dateFormatter.formatString = dateFormat;
					var result:String = dateFormatter.format(date);
					if (result)
						return result;
					else
						return dateFormatter.error;
				}else{
					return date.toLocaleString();
				}
			}
			
			private var layerDomainsCache:Dictionary = new Dictionary(); // map from queryLayer to domainsCache
			
			private function getCodedValue(fieldName:String, fieldValue:String, typeID:String):CodedValue
			{
				var result:CodedValue;
				
				var domainsCache:Object = layerDomainsCache[queryLayer];
				if (!domainsCache){
					domainsCache = {}; // map from (fieldName + typeID) to CodedValueDomain
					layerDomainsCache[queryLayer] = domainsCache;
				}
				
				var domainsKey:String = fieldName + typeID;
				var codedValueDomain:CodedValueDomain;
				
				if (domainsKey in domainsCache){
					codedValueDomain = domainsCache[domainsKey];
				}else{
					if (typeID){
						var featureType:FeatureType = getFeatureType(typeID);
						if (featureType)
							codedValueDomain = featureType.domains[fieldName] as CodedValueDomain;
					}else{
						var field:Field = getField(fieldName);
						if (field)
							codedValueDomain = field.domain as CodedValueDomain;
					}
					domainsCache[domainsKey] = codedValueDomain;
				}
				
				if (codedValueDomain){
					for each (var codedValue:CodedValue in codedValueDomain.codedValues){
						if (fieldValue == codedValue.code){
							result = codedValue;
							break;
						}
					}
				}
				return result;
			}
			
			private function popCBwithUserList(userList:String):void
			{
				configUserVals = [];
				
				var uArray:Array = StringUtil.trimArrayElements(userList,",").split(",");
				
				for each (var val:String in uArray){
					var uval:String = val;
					var ulbl:String = val;
					var uVal:Object = 
					{
						value: uval,
						label: ulbl
					}
					configUserVals.push(uVal);
				}
				
				cbSearch.dataProvider = configUserVals;
				cbSearch.visible = true;
				cbSearch.includeInLayout = true;
				txtSearch.visible = false;
				txtSearch.includeInLayout = false;
			}
			
			private function popCBwithDomain(fieldName:String):void
			{
				configDomainVals = [];
				
				var tfield:Field;
				
				var i:int = cboLayerText.selectedIndex;
				if (i == -1){
					if(configSearchText[0].layer)
						queryLayer = configSearchText[0].layer;
					else
						queryLayer = configSearchText[0].table;
				}else{
					if(configSearchText[i].layer)
						queryLayer = configSearchText[i].layer;
					else
						queryLayer = configSearchText[i].table;
				}
				
				if (queryLayer && !queryLayer.loaded){
					queryLayer.addEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
					function queryLayer_loadHandler(event:LayerEvent):void
					{
						popCBwithDomain(fieldName);
					}
					return;
				}

				var domainsCache:Object = layerDomainsCache[queryLayer];
				if (!domainsCache){
					domainsCache = {}; // map from fieldName to CodedValueDomain
					layerDomainsCache[queryLayer] = domainsCache;
				}
				
				var domainsKey:String = fieldName;
				var codedValueDomain:CodedValueDomain;
				var rangeDomain:RangeDomain;
				
				if (domainsKey in domainsCache){
					if(domainsCache[domainsKey].hasOwnProperty("codedValues"))
						codedValueDomain = domainsCache[domainsKey];
					else if (domainsCache[domainsKey].hasOwnProperty("minValue"))
						rangeDomain = domainsCache[domainsKey];
				}else{
					var field:Field = getField(fieldName);
					//
					if (field && field.domain){
						codedValueDomain = field.domain as CodedValueDomain;
						domainsCache[domainsKey] = codedValueDomain;
					//}else if (field && field.domain && field.domain.hasOwnProperty("minValue")){
					}else if (field && field.domain){
						rangeDomain = field.domain as RangeDomain;
						domainsCache[domainsKey] = rangeDomain;						
					}else{
						var stype:FeatureType;
						if(queryLayer.layerDetails){
							for each (stype in queryLayer.layerDetails.types){
								if(stype.domains[fieldName].hasOwnProperty("codedValues")){
									codedValueDomain = stype.domains[fieldName];
									domainsCache[domainsKey] = codedValueDomain;
								}
								else if (stype.domains[fieldName].hasOwnProperty("minValue")){
									rangeDomain = stype.domains[fieldName];
									domainsCache[domainsKey] = rangeDomain;
								}
							}
						}else{
							for each (stype in queryLayer.tableDetails.types){
								if(stype.domains[fieldName].hasOwnProperty("codedValues")){
									codedValueDomain = stype.domains[fieldName];
									domainsCache[domainsKey] = codedValueDomain;
								}
								else if (stype.domains[fieldName].hasOwnProperty("minValue")){
									rangeDomain = stype.domains[fieldName];
									domainsCache[domainsKey] = rangeDomain;
								}
							}
						}
					}					
				}
				
				if(codedValueDomain){
					for each (var codedValue:CodedValue in codedValueDomain.codedValues){
						var dVal:String = codedValue.code;
						var dLbl:String = codedValue.name;
						var domVal:Object = {
							value: dVal,
							label: dLbl
						}
						configDomainVals.push(domVal);
					}
					cbSearch.prompt = "";
					cbSearch.dataProvider = configDomainVals;
					cbSearch.visible = true;
					cbSearch.editable = false;
					cbSearch.includeInLayout = true;
					txtSearch.restrict = null;
					txtSearch.errorString = "";
					if(numberValidator){
						numberValidator.property = "";
						numberValidator.source = null;
					}
					txtSearch.visible = false;
					txtSearch.includeInLayout = false;
				}
				if(rangeDomain){
					
					searchBtn.removeEventListener(MouseEvent.CLICK, equeryFeaturesText);
					
					txtSearch.removeEventListener(FlexEvent.ENTER, equeryFeaturesText);
					txtSearch.errorString = "";
					txtSearch.restrict = "0-9\\.\\-";					
					numberValidator = new NumberValidator();
					numberValidator.required = false;
					numberValidator.domain = "int";
					numberValidator.source = txtSearch;
					numberValidator.property = "text";
					numberValidator.minValue = rangeDomain.minValue;
					numberValidator.maxValue = rangeDomain.maxValue;
					numberValidator.trigger = txtSearch;
					numberValidator.triggerEvent = "enter";
					numberValidator.exceedsMaxError +=  " " + rangeDomain.minValue.toString() + " - " + rangeDomain.maxValue.toString();
					numberValidator.lowerThanMinError += " " + rangeDomain.minValue.toString() + " - " + rangeDomain.maxValue.toString();
					numberValidator.addEventListener(ValidationResultEvent.VALID, equeryFeaturesText);
					
					searchBtn.addEventListener(MouseEvent.CLICK, inputValidate);
					function inputValidate(evt:Event):void
					{
						numberValidator.validate();
					}
				}
			}

			//get geom center
			private function getGeomCenter(gra:Graphic):MapPoint
			{
				var pt:MapPoint;
				switch (gra.geometry.type){
					case Geometry.MAPPOINT:{
						pt = gra.geometry as MapPoint;
						break;
					}
					case Geometry.POLYLINE:{
						var pl:Polyline = gra.geometry as Polyline;
						var pathCount:Number = pl.paths.length;
						var pathIndex:int = int((pathCount / 2) - 1);
						var midPath:Array = pl.paths[pathIndex];
						var ptCount:Number = midPath.length;
						var ptIndex:int = int((ptCount / 2) - 1);
						pt = pl.getPoint(pathIndex, ptIndex);
						break;
					}
					case Geometry.POLYGON:{
						var poly:Polygon = gra.geometry as Polygon;
						pt = poly.extent.center;
						break;
					}
				}
				return pt;
			}			
					
			private function getDrawGra():void
			{
				if(drawGraphicsLayer){
					var geom:Geometry
					var graLayAC:ArrayCollection = drawGraphicsLayer.graphicProvider as ArrayCollection;
					if (graLayAC.length > 1){
						geom = unionGeoms2(drawGraphicsLayer);
						queryFeaturesGraphical(geom, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
					}else if (graLayAC.length == 1){
						geom = (graLayAC[0] as Graphic).geometry;
						queryFeaturesGraphical(geom, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
					}else if(drawGraphicsLayer.graphicProvider.length == 0){
						showStateResults();
						showMessage("There are no graphics available",false);
					}
				}else{
					showStateResults();
					showMessage("There are no graphics available",false);
				}
			}
			
			private function getBufferGra():void
			{
				if(bufferGraphicsLayer){
					var geom:Geometry
					var graLayAC:ArrayCollection = bufferGraphicsLayer.graphicProvider as ArrayCollection;
					if (graLayAC.length > 1){
						geom = unionGeoms2(bufferGraphicsLayer);
						queryFeaturesGraphical(geom, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
					}else if (graLayAC.length == 1){
						geom = (graLayAC[0] as Graphic).geometry;
						queryFeaturesGraphical(geom, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
					}else if(bufferGraphicsLayer.graphicProvider.length == 0){
						showStateResults();
						showMessage("There are no graphics availible",false);
					}
				} else {
					showStateResults();
					showMessage("There are no graphics availible",false);
				}
			}
			
			private function checkForeDrawGL(evt:Event):void
			{
				MapUtil.forEachMapLayer(map, function(layer:Layer):void
				{
					if(layer.name.toLowerCase() == "draw features"){
						drawGraphicsLayer = layer as GraphicsLayer;
						drawGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_ADD, checkeDrawNumGras);
						drawGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_REMOVE, checkeDrawNumGras);
						drawGraphicsLayer.addEventListener(GraphicsLayerEvent.GRAPHICS_CLEAR, checkeDrawNumGras);
					}
				});
			}
			
			private function checkeDrawNumGras(event:Event):void
			{
				if (!executingURLquery)
					clearMessage();
				if(drawGraphicsLayer){
					eDrawBtn.filters = (drawGraphicsLayer.numGraphics > 0)?[]:[cOver];
					eDrawBtn.buttonMode = eDrawBtn.useHandCursor = eDrawBtn.enabled = (drawGraphicsLayer.numGraphics > 0);
				}
			}
			
			private function checkForpntBufferGL(evt:Event):void
			{
				MapUtil.forEachMapLayer(map, function(layer:Layer):void
				{
					if(layer.name.toLowerCase() == "buffer results"){
						bufferGraphicsLayer = layer as GraphicsLayer;
						bufferGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_ADD, checkBufferNumGras);
						bufferGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_REMOVE, checkBufferNumGras);
						bufferGraphicsLayer.addEventListener(GraphicsLayerEvent.GRAPHICS_CLEAR, checkBufferNumGras);
					}
				});
			}
			
			private function checkBufferNumGras(event:Event):void
			{
				if (!executingURLquery)
					clearMessage();
				if(bufferGraphicsLayer){
					pBufferBtn.filters = (bufferGraphicsLayer.numGraphics > 0)?[]:[cOver];
					pBufferBtn.buttonMode = pBufferBtn.useHandCursor = pBufferBtn.enabled = (bufferGraphicsLayer.numGraphics > 0);
				}
			}
			
			private function clear():void
			{
				addSharedData("Deactivate_DrawTool", null); // to be able to deactivate drawTool on other widgets
				
				//hide infowindow if any
				hideInfoWindow();
				
				//resize window
				wTemplate.width = 665;
				wTemplate.height = 590;
				
				if(currentState == "resultsList"){
					currentState = lState;
					if(lState == "graphicalInput"){
						wTemplate.selectedTitlebarButtonIndex = 0;
					}else if (lState == "textInput"){
						wTemplate.selectedTitlebarButtonIndex = 1;
					}
					else if (lState == "fieldInput"){
						wTemplate.selectedTitlebarButtonIndex = 3;
					}
					else{
						wTemplate.selectedTitlebarButtonIndex = 4;
					}
				}
				
				map.getLayer("EcoDAAT").visible = true;
				
				graphicsLayer.clear();
				graphicsLayerBuffer.clear();
				graGraphicsLayer.clear();
				clearMessage();
				txtSearch.text = "";
				txtSearch.errorString = "";
				sumField = "";
				searchResultAC = null;
				if(floatorfixed == "fixed")
					addSharedData("clearFixedDatagrid", null);
				if(floatorfixed == "fixed")
					addSharedData("clearRelateFixedDatagrid", null);
			}
			
			private function clearBuffer():void
			{
				graphicsLayerBuffer.clear();
			}		
			
			private var hitimer:uint;
			private var Hits:Array = new Array();									
			
			private function showMessage(msg:String, swfVisible:Boolean):void
			{
				txtMessage.text = msg;
				swfMessage.visible = swfVisible;
				msgVisible = true;
			}			
			
			private function clearMessage():void
			{
				msgVisible = false;
			}
			
			private function clickSearchResult(event:Event):void
			{
				//var recAC:ArrayCollection = searchResultDG.dataProvider as ArrayCollection;
				var searchResult:SearchResult = ItemRenderer(event.target).data as SearchResult;
				unhighlightDataGroupItems();
				searchResult.selected = true;
				
				if(lState == "textInput"){
					var i:Number = cboLayerText.selectedIndex;
					zoomScale = configSearchText[i].zoomscale;
					zoomPercent = configSearchText[i].zoompercent;
				} else if(lState == "graphicalInput"){
					var i2:Number = cboLayerGraphical.selectedIndex;
					zoomScale = configSearchGraphical[i2].zoomscale;
					zoomPercent = configSearchGraphical[i2].zoompercent;
				}
				
				if (searchResult.geometry){
					if (searchResult.geometry.type == Geometry.MAPPOINT){
						if(isNaN(zoomScale)){
							map.zoom(1 / 16, searchResult.point);
							map.centerAt(searchResult.point);
						}else{
							if (map.scale > zoomScale)
								map.scale = zoomScale;
							map.centerAt(searchResult.point);
						}
					}else{
						if(isNaN(zoomScale)){
							map.extent = searchResult.geometry.extent.expand(zoomPercent);
							if (!map.extent.contains(searchResult.geometry))
								map.level--;
						}else{
							if (map.scale > zoomScale)
								map.scale = zoomScale;
							map.centerAt(searchResult.point);
						}
					}
				}
				
				Hits.length = 0;
				
				if(floatorfixed == "fixed"){
					var dgConfig:Object = {
						searchResultoid: searchResult.oid
					}
					var dgconfigArr:ArrayCollection = new ArrayCollection();
					dgconfigArr.addItem(dgConfig);
					addSharedData("scrollFixedDataGrid", dgconfigArr);
				}
			}
			
			private function mouseOverSearchResult(event:Event):void
			{
				clearTimeout(hitimer);
				var searchResult:SearchResult = ItemRenderer(event.target).data as SearchResult;
				if(searchResult.point){
					if (map.extent.containsXY(searchResult.point.x, searchResult.point.y)) // only show infowindow if search result in contained within map extent
						hitimer = setTimeout(showHighlight, 300, [ searchResult ]);
					else
						hideInfoWindow();
				}
				
				Hits.length = 0;
				
				if(floatorfixed == "fixed"){
					var dgConfig:Object = {
						searchResultoid: searchResult.oid
					}
					var dgconfigArr:ArrayCollection = new ArrayCollection();
					dgconfigArr.addItem(dgConfig);
					addSharedData("scrollFixedDataGrid", dgconfigArr);
				}
			}
			
			private function mouseOutSearchResult(event:Event):void
			{
				clearTimeout(hitimer);
			}
			
			private function widgetOpenedHandler(event:Event):void
			{
				if(graphicsLayer)
					graphicsLayer.visible = true;
				if (graphicsLayerBuffer)
					graphicsLayerBuffer.visible = true;
				if (graGraphicsLayer)
					graGraphicsLayer.visible = true;
			}
			
			public function highlightDataGroupItemByOID(oid:Number):void
			{
				if(widgetAndGridIteract){
					for (var i:Number = 0; i < searchResultAC.length; i++){
						var sr:SearchResult = searchResultAC[i];
						if(sr.oid == oid){
							sr.selected = true;
							/* var spDelta:Point = searchResultDG.layout.getScrollPositionDeltaToElement(i);
							if (spDelta)
								searchResultDG.verticalScrollPosition += spDelta.y; */
							break;
						}
					}
				}
			}
			
			public function highlightDataGroupItem(gra:Graphic):void
			{
				if(widgetAndGridIteract){
					//var recAC:ArrayCollection = searchResultDG.dataProvider as ArrayCollection;
					if(gra){
						var sr:SearchResult = gra.attributes as SearchResult;						
						/* for (var i:Number = 0; i < recAC.length; i++){
							var sr1:SearchResult = searchResultAC[i];
							if(sr1.oid === sr.oid){
								sr1.selected = true;
								var spDelta:Point = searchResultDG.layout.getScrollPositionDeltaToElement(i);
								if (spDelta)
									searchResultDG.verticalScrollPosition += spDelta.y; 
								break;
							}
						} */
					}
				}
			}
			
			public function clearSelected():void
			{
				/* var recAC:ArrayCollection = searchResultDG.dataProvider as ArrayCollection;
				if(recAC){
					for (var i:Number = 0; i < recAC.length; i++){
						var sr:SearchResult = searchResultAC[i];
						sr.selected = false;
					}
				} */
			}
			
			public function unhighlightDataGroupItems():void
			{
				if(widgetAndGridIteract){
					/* var recAC:ArrayCollection = searchResultDG.dataProvider as ArrayCollection;
					for (var i:Number = 0; i < recAC.length; i++){
						var sr:SearchResult = searchResultAC[i];
						if(sr.oid == sr.oid)
							sr.selected = false;
					} */
				}
			}
			
			private function showHighlight(params:Array):void
			{
				var showHighlightPoint:MapPoint = params[0].point as MapPoint;
				popUpRenderer.popUpInfo = configurePopUpInfo(params[0].graphic.attributes.links);
				popUpRenderer.graphic = params[0].graphic;
				popUpRenderer.setStyle("skinClass", Class(widgets.Identify.PopUpRendererSkin));
				map.infoWindow.content = popUpRenderer;
				map.infoWindow.contentOwner = popUpRenderer.graphic;
				map.infoWindow.show(showHighlightPoint);
			}
			
			private function configurePopUpInfo(links:Array):PopUpInfo
			{
				var popUpInfo:PopUpInfo = new PopUpInfo;
				popUpInfo.title = "{title}";
				popUpInfo.description = "{content}";
				var pminfos:Array = [];
				
				for(var l:int=0; l<links.length; l++){
					/*if (links[l].link){
						var pos:Number = links[l].link.length - 4;
						var sfx:String = String(links[l].link).substr(pos, 4).toLowerCase();
						if ((sfx == ".jpg") || (sfx == ".png") || (sfx == ".gif")){ // use PopUpMediaInfo if it is an image
							var popUpMediaInfo:PopUpMediaInfo = new PopUpMediaInfo;
							popUpMediaInfo.type = PopUpMediaInfo.IMAGE;
							popUpMediaInfo.imageLinkURL = links[l].link;
							popUpMediaInfo.imageSourceURL = links[l].link;
							pminfos.push(popUpMediaInfo);
						}else{
							var lText:String = (links[l].alias != "") ? links[l].alias : links[l].link;
							popUpInfo.description += "<br /><a href='" + links[l].link + "'>" + lText + "</a>"
						}
					}*/
				}
				popUpInfo.popUpMediaInfos = pminfos;
				
				return popUpInfo;
			}
			
			private function showStateGraphicalSearch():void
			{
				lState = currentState;
				currentState = "graphicalInput";
				
				wTemplate.width = 665;
				wTemplate.height = 590;
			}
			
			private function showStateTextSearch():void
			{
				addSharedData("Deactivate_DrawTool", null);
				lState = currentState;
				currentState = "textInput";
				
				wTemplate.width = 665;
				wTemplate.height = 590;
			}
			
			private function showStateTextSearch2():void
			{
				if(querySum.text.search("Spatial Search")>-1)
				{
					showStateGraphicalSearch();
				}
				else{
					showStateTextSearch();
				}				
			}
			
			private function showTimeSettings():void
			{
				wTemplate.width = 665;
				wTemplate.height = 590;
				lState = currentState;
				currentState = "timeInput";
				if(configSearchText.length){
					if(configSpatialSearchLayers.length)
						wTemplate.selectedTitlebarButtonIndex = 4;
					else
						wTemplate.selectedTitlebarButtonIndex = 3;
				}else{
					if(configSpatialSearchLayers.length)
						wTemplate.selectedTitlebarButtonIndex = 3;
					else
						wTemplate.selectedTitlebarButtonIndex = 2;
				}
			}
			
			private function showStateResults():void
			{
				wTemplate.width = 436;
				wTemplate.height = 500;
				lState = currentState;
				currentState = "resultsList";
				if(configSearchText.length){
					if(configSpatialSearchLayers.length)
						wTemplate.selectedTitlebarButtonIndex = 4;
					else
						wTemplate.selectedTitlebarButtonIndex = 3;
				}else{
					if(configSpatialSearchLayers.length)
						wTemplate.selectedTitlebarButtonIndex = 3;
					else
						wTemplate.selectedTitlebarButtonIndex = 2;
				}
			}
			
			private function showfields():void
			{
				wTemplate.width = 665;
				wTemplate.height = 590;
				lState = currentState;
				currentState = "fieldInput";
				if(configSearchText.length){
					if(configSpatialSearchLayers.length)
						wTemplate.selectedTitlebarButtonIndex = 4;
					else
						wTemplate.selectedTitlebarButtonIndex = 3;
				}else{
					if(configSpatialSearchLayers.length)
						wTemplate.selectedTitlebarButtonIndex = 3;
					else
						wTemplate.selectedTitlebarButtonIndex = 2;
				}
			}
			
			private function widgetClosedHandler(event:Event):void
			{
				setMapAction(null, null, null, null);
				//graphicsLayer.visible = false;
				if(bufferGraphicsLayer)
					//bufferGraphicsLayer.visible = false;
				if(graGraphicsLayer)
					//graGraphicsLayer.visible = false;
				hideInfoWindow();
				setMapNavigation(null, null);
				
				if (selectedDrawingIcon)
					selectedDrawingIcon = null;
			}
			
			private function graphicsLayer_hideHandler(event:FlexEvent):void
			{
				hideInfoWindow();
			}
			
			private function sldrDataTipFormatter(value:Number):String 
			{ 
				return int(value * 100) + "%"; 
			}
			
			private function fnInit():void
			{
				cbSearch.addEventListener(ListEvent.ITEM_ROLL_OVER,fnCreToolTip);
				cbSearch.addEventListener(ListEvent.ITEM_ROLL_OUT,fnCreToolTip);
				cbSearch.addEventListener(ListEvent.CHANGE,fnCreToolTip);
			}
			
			private function fnCreToolTip(e:ListEvent):void
			{
				switch(e.type)
				{
					case ListEvent.ITEM_ROLL_OVER:{
						try{
							ToolTipManager.destroyToolTip(myTip);
						}
						catch(error:Error){}
						//creates a tooltip.
						myTip = ToolTipManager.createToolTip(cbSearch.dataProvider[e.rowIndex].label,stage.mouseX+10,stage.mouseY) as ToolTip; // array2 is id of arraylist  
						break;
					}
					case ListEvent.ITEM_ROLL_OUT:{
						//destroy the created tooltip, so that we can create a new one for others.
						try{
							ToolTipManager.destroyToolTip(myTip);
						}
						catch(error:Error){}
						break;
					}
					case ListEvent.CHANGE:{
						//destroy the created tooltip, so that we can create a new one for others.
						try{
							ToolTipManager.destroyToolTip(myTip);
						}
						catch(error:Error){}
						break;
					}
				}
			}
			
			private function zoomAll():void
			{
				if(resultsFeatureSet){
					if (resultsFeatureSet.features.length == 1 
						&& resultsFeatureSet.features[0].geometry.type == Geometry.MAPPOINT){
						var mp:MapPoint = resultsFeatureSet.features[0].geometry as MapPoint;
						map.zoom(1 / 16, mp);
						map.centerAt(mp);
					}else{
						var graphicsExtent:Extent = GraphicUtil.getGraphicsExtent(resultsFeatureSet.features);
						map.extent = graphicsExtent.expand(zoomPercent);
						// make sure the whole extent is visible
						if (!map.extent.contains(graphicsExtent.expand(zoomPercent)))
							map.level--;
					}
				}
			}
			
			private function geometryService_faultHandler(event:FaultEvent):void
			{
				Alert.show(event.fault.toString(), wTemplate.widgetTitle,4,wTemplate);
			}
			
			private function iconRollOverHandler(event:MouseEvent):void
			{
				clearSelectionFilter();
				event.target.filters = [ glowFilter ];
			}
			
			private function iconRollOutHandler(event:MouseEvent):void
			{
				clearSelectionFilter();
			}
			
			private function clearSelectionFilter():void
			{
				for (var i:int = 0; i < imageGroup.numChildren; i++){
					if (imageGroup.getChildAt(i).filters && imageGroup.getChildAt(i).filters.length > 0){
						if (!(selectedDrawingIcon && imageGroup.getChildAt(i) === selectedDrawingIcon)){
							if(imageGroup.getChildAt(i)!== eDrawBtn && imageGroup.getChildAt(i)!== pBufferBtn)
								imageGroup.getChildAt(i).filters = [];
						}
					}
				}
			}
			
			private function sharedDataUpdated(event:AppEvent):void
			{
				var data:Object = event.data;
				
				if (data.key == "Deactivate_DrawTool"){
					setMapAction(null, null, null, null);
					if (selectedDrawingIcon){
						selectedDrawingIcon.filters = [];
						selectedDrawingIcon = null;
					}
				}
			}
			
			private function hideInfoWindow():void
			{
				if (map.infoWindow.contentOwner &&
					((map.infoWindow.contentOwner is Graphic && Graphic(map.infoWindow.contentOwner).graphicsLayer === graphicsLayer) || map.infoWindow.contentOwner is Map))
					map.infoWindow.hide();
			}
			
			public function checkAll(event:MouseEvent):void {
				if(event.currentTarget.selected == true)
				{
					for(var i:int=0; i < dg.dataProvider.length; i++){
						dg.dataProvider[i].gridfield="true";
					}
				}
				else{
					for(var i:int=0; i < dg.dataProvider.length; i++){
						dg.dataProvider[i].gridfield="false";
					}
				}
				//fieldsArray.refresh();
				dg.dataProvider.refresh();
			}
			
			public function checkAllmonth(event:MouseEvent):void {
				if(event.currentTarget.selected == true)
				{
					for(var i:int=0; i < monthArray.length; i++){
						monthArray[i].gridfield="true";
					}
				}
				else{
					for(var i:int=0; i < monthArray.length; i++){
						monthArray[i].gridfield="false";
					}
				}
				var dataSortField:SortField = new SortField();
				dataSortField.name = "alias";
				dataSortField.numeric = false;
				var numericDataSort:Sort = new Sort();
				numericDataSort.fields = [dataSortField];
				
				monthArray.sort = numericDataSort;
				monthArray.refresh();
				dgMonth.dataProvider.refresh();
			}
			public function checkAllyear(event:MouseEvent):void {
				if(event.currentTarget.selected == true)
				{
					for(var i:int=0; i < yearArray.length; i++){
						yearArray[i].gridfield="true";
					}
				}
				else{
					for(var i:int=0; i < yearArray.length; i++){
						yearArray[i].gridfield="false";
					}
				}
				var dataSortField:SortField = new SortField();
				dataSortField.name = "alias";
				dataSortField.numeric = true;
				var numericDataSort:Sort = new Sort();
				numericDataSort.fields = [dataSortField];
				numericDataSort.reverse();
				
				yearArray.sort = numericDataSort;
				yearArray.refresh();
				dgYear.dataProvider.refresh();
			}
			
			public function checkAllspatial(event:MouseEvent):void {
				if(event.currentTarget.selected == true)
				{
					for(var i:int=0; i < fieldsArray2.length; i++){
						fieldsArray2[i].gridfield="true";
					}
				}
				else{
					for(var i:int=0; i < fieldsArray2.length; i++){
						fieldsArray2[i].gridfield="false";
					}
				}
				var dataSortField:SortField = new SortField();
				dataSortField.name = "name";
				dataSortField.numeric = false;
				var numericDataSort:Sort = new Sort();
				numericDataSort.fields = [dataSortField];
				
				fieldsArray2.sort = numericDataSort;
				fieldsArray2.refresh();
				dg2.dataProvider.refresh();
			}
			
			private function updateMultiSelect():void
			{
				if(databaseText.selectedLabel == 'Zooplankton')
				{
					ichOptions = false;
					trawlOptions = false;
					bobOptions = true;
					bobGroup.includeInLayout = true;
					trawlGroup.includeInLayout = false;
					ichGroup.includeInLayout = false;
					bobGroup.visible = true;
					trawlGroup.visible = false;
					ichGroup.visible = false;
				}
				if(databaseText.selectedLabel == 'TRAWL')
				{
					ichOptions = false;
					trawlOptions = true;
					bobOptions = false;
					bobGroup.includeInLayout = false;
					trawlGroup.includeInLayout = true;
					ichGroup.includeInLayout = false;
					bobGroup.visible = false;
					trawlGroup.visible = true;
					ichGroup.visible = false;
				}
				if(databaseText.selectedLabel == 'Ichthyoplankton')
				{
					ichOptions = true;
					trawlOptions = false;
					bobOptions = false;
					bobGroup.includeInLayout = false;
					trawlGroup.includeInLayout = false;
					ichGroup.includeInLayout = true;
					bobGroup.visible = false;
					trawlGroup.visible = false;
					ichGroup.visible = true;
				}
			}
			
			private function unclusterPoints():void
			{
				if(unclusterCheck.selected == true)
				{
					if(graphicsLayer.numGraphics >3200)
					{
						unclusterCheck.selected = false;
						Alert.show("There are too many selected points to veiw individual points.  \n\nZoom in to view detailed clustered data.","Alert");
					}
					else if (graphicsLayer.numGraphics <1)
					{
						unclusterCheck.selected = false;
						Alert.show("There are no selected points on map.","Alert");
						showStateTextSearch();
					}
					else{
						graphicsLayer.clusterer = null;
						graphicsLayer.symbol = selectedPoint;
						graphicsLayer.removeEventListener(FlareMouseEvent.FLARE_CLICK, flareClickHandler);
						graphicsLayer.addEventListener(MouseEvent.CLICK,pointClickHandler);
					}
				}
				else{
					graphicsLayer.clusterer = clusterer;
					graphicsLayer.addEventListener(FlareMouseEvent.FLARE_CLICK, flareClickHandler);
					graphicsLayer.removeEventListener(MouseEvent.CLICK,pointClickHandler);
				}
			}
			
			private function filterFields(arc:ArrayCollection,fieldAr:Array,searchList:String):ArrayCollection{
				var newFieldList:ArrayCollection = new ArrayCollection();
				//set a few attributes default to return 
				for(var ii:int=0; ii < arc.length; ii++){
					arc[ii].gridfield = "false";
					arc[ii].sortNumber = '-1';
					for(var i:int=0; i < fieldAr.length; i++){
						if(String(fieldAr[i]).toUpperCase() == String(arc[ii].name).toUpperCase()){
							arc[ii].gridfield = "true";
							arc[ii].sortNumber = i;
						}
					}
					//filter layers out from config list
					if(searchList.toUpperCase().search(String(arc[ii].name).toUpperCase()) != -1){
						newFieldList.addItem(arc[ii]);
					}
				}
				var dataSortField:SortField = new SortField();
				dataSortField.name = "sortNumber";
				dataSortField.numeric = true;
				var numericDataSort:Sort = new Sort();
				numericDataSort.fields = [dataSortField];
				numericDataSort.reverse();
				
				newFieldList.sort = numericDataSort;
				newFieldList.refresh();
				return newFieldList;
			}
			
			protected function sampleTypeList_changeHandler(event:ListEvent):void
			{				
				var fac:ArrayCollection = new ArrayCollection;
				fac.source = fieldResultMain.source;
				if(sampleTypeList.selectedLabel == "ICH"){
					var fieldArray:Array = ich_fields.split(",");
					dg.dataProvider = filterFields(fac,fieldArray,ich_fieldsL);
				}
				else if(sampleTypeList.selectedLabel == "TRAWL"){
					var fieldArray:Array = trawl_fields.split(",");
					dg.dataProvider = filterFields(fac,fieldArray,trawl_fieldsL);
				}
				else if(sampleTypeList.selectedLabel == "ZOOP"){
					var fieldArray:Array = zoop_fields.split(",");
					dg.dataProvider = filterFields(fac,fieldArray,zoop_fieldsL);
				}
				else{
					dg.dataProvider = fieldResultMain;
				}
			}
		]]>
	</fx:Script>
	<viewer:WidgetTemplate id="wTemplate"
						   closed="widgetClosedHandler(event)" 
						   open="widgetOpenedHandler(event)"
						   width="665" height="580"
						   minHeight="190"
						   minWidth="260"
						   visible="false">
		<!-- Spatial Search-->
		<s:Group id="graphicalInput"
				 width="100%" height="100%"
				 visible="false"
				 visible.graphicalInput="true">
			<s:layout>
				<s:VerticalLayout gap="6" horizontalAlign="center"/>
			</s:layout>
			<s:Label color="0x000000" fontWeight="bold" fontSize="15" paddingTop="6" paddingBottom="6" text="Spatial Map Query Only"/>
			<s:HGroup id="boxGraphical"
					  width="100%"
					  gap="15"
					  horizontalAlign="center" verticalAlign="middle">
				<s:Label color="0xA80000" fontWeight="bold" fontSize="13" id="lblLayerGraphical" text="1. Select Map Layer to Query"/>
				<mx:ComboBox id="cboLayerGraphical" change="searchLayerChangedGraphical()"/>
			</s:HGroup>
			<s:Label color="0xA80000" fontWeight="bold" paddingTop="8" paddingBottom="8" text="2. Select Column Fields to view in Table" fontSize="13"/>
			<mx:DataGrid  id="dg2" horizontalGridLines="true" verticalGridLines="true" allowMultipleSelection="true" headerHeight="30"  rowCount="9" headerStyleName="accHead" width="245" dataProvider="{fieldsArray2}">
				<mx:columns>
					<mx:DataGridColumn sortable="false" width="29" textAlign="center">
						<mx:headerRenderer>
							<fx:Component>
								<mx:CheckBox toolTip="Select all Fields" paddingLeft="7" click="outerDocument.checkAllspatial(event)"/>
							</fx:Component>
						</mx:headerRenderer>
						<mx:itemRenderer>
							<fx:Component>
								<mx:CheckBox toolTip="Select This Field" paddingLeft="7" selected="{(data.gridfield == 'true')?true:false}" click="{data.gridfield = (data.gridfield != 'true') ? 'true' : 'false';}"/>
							</fx:Component>
						</mx:itemRenderer>
					</mx:DataGridColumn>
					<mx:DataGridColumn dataField="alias" headerText="Attribute Fields" />
				</mx:columns>
			</mx:DataGrid>
			<s:Label id="txtLabelGraphical"
					 width="100%" fontSize="13" paddingBottom="10" paddingTop="10"
					 color="0xA80000" fontWeight="bold"
					 textAlign="center"/>
			<s:HGroup id="imageGroup"
					  width="100%"
					  gap="10"
					  horizontalAlign="center">
				<mx:Image id="eDrawBtn"
						  width="0" height="40"
						  click="getDrawGra()"
						  source= "widgets/eSearch/assets/images/i_draw_draw.png"
						  toolTip="{drawGraLabel}" 
						  visible="false"
						  includeInLayout="{eDrawEnabled}" />
				<mx:Image id="pBufferBtn"
						  width="0" height="40"
						  click="getBufferGra()"
						  source= "widgets/eSearch/assets/images/i_draw_buffer.png"
						  toolTip="{bufferGraLabel}" 
						  visible="false"
						  includeInLayout="{pBufferEnabled}" />
				<mx:Image id="iSearchPnt"
						  name="{DrawTool.MAPPOINT}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateSearchTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_point.png"
						  toolTip="{pointLabel}"
						  useHandCursor="true"/>
				<mx:Image id="iSearchLine"
						  name="{DrawTool.POLYLINE}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateSearchTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_line.png"
						  toolTip="{lineLabel}"
						  useHandCursor="true"/>
				<mx:Image id="iSearchExt"
						  name="{DrawTool.EXTENT}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateSearchTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_rect.png"
						  toolTip="{rectangleLabel}"
						  useHandCursor="true"/>
				<mx:Image id="iSearchPoly"
						  name="{DrawTool.POLYGON}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateSearchTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_poly.png"
						  toolTip="{polygonLabel}"
						  useHandCursor="true"/>
				
				<s:Button click="clear()"
						 fontWeight="bold" fontSize="13"
						 label="Clear Current Selection"/>
			</s:HGroup>
			<s:HGroup width="100%"
					  horizontalAlign="right"
					  verticalAlign="middle"
					  paddingRight="10"
					  paddingTop="2" gap="10">
				<s:CheckBox id="graMultiChk" selected="{multiPartGraphicSearch}" label="{enableMultiPartSearch}" change="graMultiChanged()"/>
				<s:Button id="graFeatureQueryBtn" click="queryFeaturesGra()" color="red" fontWeight="bold" label="{submitLabel}"/>
				<s:CheckBox id="addTolerance" selected="{applyTolleranceByDefault}" label="{lblTolerance}"/>
			</s:HGroup>
			<s:HGroup verticalAlign="middle">
				<s:CheckBox id="bufferUserGraphic" selected="false" fontWeight="bold" toolTip="Use especially for Line Search" label="{lblbufferUserGraphic}"/>
				<s:TextInput id="textGraInputBuffer" text="2000" width="40" />
				<mx:ComboBox id="cboGraBufferUnit" />
				<s:HSlider id="hsGraBufferAlpha" width="55" value="0.5" minimum="0" maximum="1" snapInterval="0.1"
						   toolTip="{bufferAlphaLabel}" dataTipFormatFunction="sldrDataTipFormatter"
						   skinClass="widgets.eSearch.skins.alphaSliderSkin"/>
				<mx:ColorPicker id="cpGraBufferColor" selectedColor="#01b9fd" visible="false" toolTip="{bufferColorLabel}" />
			</s:HGroup>
			<s:HGroup paddingTop="10" gap="20">
				<s:Button label="Search current Map" color="red" fontWeight="bold" toolTip="Search with just Map graphic" click="queryFeaturesGra()" enabled="{graGraphicsLayer.graphicProvider.length> 0}" />
				<s:Button label="Refine Text Search" fontWeight="bold" toolTip="Use map and text combination for search" click="showStateTextSearch()" />
			</s:HGroup>
		</s:Group>
		
		<s:Group id="textInput"
				 width="100%" height="100%"
				 visible="false"
				 visible.textInput="true">
			<s:layout>
				<s:VerticalLayout gap="5" horizontalAlign="center"/>
			</s:layout>
			<s:Label color="0x000000" fontWeight="bold" fontSize="15" paddingTop="2" paddingBottom="3" text="Data Query and Selection"/>
			<s:HGroup id="boxText"
					  width="100%" paddingTop="3"  gap="15"
					  horizontalAlign="left" verticalAlign="middle">
				<s:Label color="0xA80000" fontWeight="bold" id="lblLayerText" text="{layerLabel}"/>
				<mx:ComboBox id="cboLayerText" change="searchLayerChangedText()" styleName="myCustomDropdownStyleName"/>
				<s:CheckBox id="useSpatial" label="*Use Spatial Search" selected="{graGraphicsLayer.graphicProvider.length> 0}" toolTip="Geometry is from Spatial Query Page.  This will use combination of text and spatial search." visible="{graGraphicsLayer.graphicProvider.length> 0}"/>
			</s:HGroup>
			<s:HGroup paddingTop="13" id="boxTextexpr" includeInLayout="{optionAttribute}" visible="{optionAttribute}"
					  width="100%" gap="15"
					  horizontalAlign="left"  verticalAlign="middle">
				<s:Label color="0xA80000" fontWeight="bold" id="lblExprText" text="{layerExprLabel}"/>
				<mx:ComboBox id="cboLayerExpr" change="searchLayerExprChangedText()"/>
			</s:HGroup>
			
			<s:HGroup gap="15"  paddingTop="13" verticalAlign="middle" horizontalAlign="left" includeInLayout="{optionAttribute}" visible="{optionAttribute}"  width="100%">
				<s:RichEditableText id="txtLabelText"
									selectable="true"
									editable="false"
									text=""  color="0xA80000" fontWeight="bold"
									textAlign="center"/>
				<mx:ComboBox id="cbSearch" creationComplete="{fnInit();}" 
							 visible="false" includeInLayout="false" 
							 labelField="label"/>
				<s:TextInput id="txtSearch" />
			</s:HGroup>
			<s:VGroup width="100%" visible="{multipleSearch}"  paddingTop="3"
					  gap="8" includeInLayout="{multipleSearch}"
					  horizontalAlign="center"  verticalAlign="middle">
				<s:HGroup verticalAlign="middle" horizontalAlign="left" includeInLayout="{!sampleSearch}" visible="{!sampleSearch}">
					<s:Label color="black" id="databaseTypeLabel" paddingRight="20" fontWeight="bold" fontSize="14" text="Choose Sample Type"/>
					<mx:ComboBox id="databaseText" includeInLayout="{!microZoopVisible}" visible="{!microZoopVisible}" change="updateMultiSelect()" dataProvider="['Zooplankton','Ichthyoplankton','TRAWL']" />				
					<s:Label color="0xA80000" includeInLayout="{hideotherOptions}" visible="{hideotherOptions}" fontWeight="bold" text="Performance"/>
					<MultiDropDown:ComboCheck width="88" includeInLayout="{hideotherOptions}" visible="{hideotherOptions}" deselectAll="{haulPerText.selectedAll = false}" selectAll="{haulPerText.selectedAll = true}" id="haulPerText" selectAllLabelField="selectall" labelField="alias" dataProvider="{new ArrayCollection([{selectall:true, alias:'ALL'},{selectall:false, alias:'GOOD'},{selectall:false, alias:'LOST'},{selectall:false, alias:'FAIL'},{selectall:false, alias:'QUEST'}])}"/>
					<s:Label color="0xA80000" fontWeight="bold" visible="{bobOptions}"  text="Sex"/>
					<mx:ComboBox id="sexText" visible="{bobOptions}" width="117" dataProvider="['ALL','Male','Female','Not determined']"/>
				</s:HGroup>
				<s:VGroup includeInLayout="{bobOptions}" id="bobGroup" width="100%" gap="5" horizontalAlign="center"  verticalAlign="middle">
					<s:HGroup width="100%" gap="10" horizontalAlign="left" visible="{bobOptions}" includeInLayout="{bobOptions}" verticalAlign="middle">
						<s:HGroup width="285" verticalAlign="middle">
							<s:Label width="150" color="0xA80000" fontWeight="bold" text="Min Volume Displacement:"/>
							<s:NumericStepper width="65" id="minDisp" maximum="5000" minimum="-1000" value="0"/>
						</s:HGroup>
						<s:Label width="160" color="0xA80000" fontWeight="bold" text="Max Volume Displacement:"/>
						<s:NumericStepper id="maxDisp" width="65" value="3400" minimum="-1000" maximum="5000"/>
						<s:CheckBox id="showallDisp"  label="All" selected="true"/>
					</s:HGroup>
					<s:HGroup width="100%" gap="4" horizontalAlign="left"  visible="{bobOptions}" includeInLayout="{bobOptions}"  verticalAlign="middle">
						<s:HGroup width="330" verticalAlign="middle">
							<s:Label width="130" color="0xA80000" fontWeight="bold" text="Taxon Name:"/>
							<MultiDropDown:ComboCheck rowCount="6" width="100%" deselectAll="{taxaBob.selectedAll = false}" selectAll="{taxaBob.selectedAll = true}" id="taxaBob" selectAllLabelField="selectall" labelField="alias" dataProvider="{taxonArray}"/>
						</s:HGroup>
						<s:Label width="101" paddingLeft="15" color="0xA80000" fontWeight="bold" text="Stage:"/>
						<MultiDropDown:ComboCheck width="143" deselectAll="{stageBob.selectedAll = false}" selectAll="{stageBob.selectedAll = true}" id="stageBob" selectAllLabelField="selectall" labelField="name" 
												  dataProvider="{new ArrayCollection([{selectall:true, name:'SELECT ALL',alias:'SELECT ALL'},{selectall:false,alias:62, name:'Calyptopis 2'},{selectall:false, name:'Calyptopis ND',alias:60},{selectall:false, name:'Calyptopis 1',alias:61},{selectall:false, alias:29, name:'Furcilia'},{selectall:false, alias:3, name:'Medusa'},{selectall:false, alias:11, name:'Egg'},{selectall:false, alias:13, name:'Nauplius'},{selectall:false, alias:999, name:'ND'},{selectall:false, alias:0, name:'Adult'},{selectall:false, alias:80, name:'Juvenile'},{selectall:false, alias:70, name:'Zoea'},{selectall:false, alias:75, name:'Megalopae'},{selectall:false, alias:51, name:'Larva'},{selectall:false, alias:63, name:'Calyptopis 3'},{selectall:false, alias:25, name:'Cypris'},{selectall:false, alias:23, name:'CIV'},{selectall:false, alias:24, name:'CV'},{selectall:false, alias:21, name:'CII'},{selectall:false, alias:20, name:'CI'},{selectall:false, alias:22, name:'CIII'},{selectall:false, alias:240, name:'CV + CVI'},{selectall:false, alias:64, name:'Adult and Juvenile'}])}"/>
					</s:HGroup>
					<s:HGroup paddingBottom="-10" paddingTop="-1" width="100%" gap="4" horizontalAlign="left"  visible="{bobOptions}" includeInLayout="{bobOptions}"  verticalAlign="middle">
						<s:Label enabled="false" toolTip="Not Defined yet" color="0xA80000" fontWeight="bold"  width="132" text="Protocol Zoop Type:"/>
						<MultiDropDown:ComboCheck width="252"  selectAllLabelField="selectall" labelField="name"  deselectAll="{typeBob.selectedAll = false}" selectAll="{typeBob.selectedAll = true}" id="typeBob" enabled="true" 
												  dataProvider="{new ArrayCollection([{selectall:true, alias:'SELECT ALL', name:'SELECT ALL'},{selectall:false, name:'Macrozooplankton', alias:1},{selectall:false, alias:2,name:'Predator'},{selectall:false,alias:3, name:'Pseudocalanus'},{selectall:false,alias:4, name:'Microzooplankton'},{selectall:false,alias:5, name:'Macrozooplankton and Predator'},{selectall:false,alias:6, name:'Macrozooplankton and Pseudocalanus'},{selectall:false,alias:7, name:'Macro and Microzooplankton'}])}"/>
						<s:Label color="0xA80000" width="44" fontWeight="bold" text="Size:"/>
						<MultiDropDown:ComboCheck width="143"  selectAllLabelField="selectall" labelField="name"  deselectAll="{sizeBob.selectedAll = false}" selectAll="{sizeBob.selectedAll = true}" id="sizeBob" enabled="true" 
												  dataProvider="{new ArrayCollection([{selectall:true, alias:'SELECT ALL', name:'SELECT ALL'},{selectall:false, name:'&#62;= 5 mm', alias:1},{selectall:false, alias:2,name:'&#60; 5 mm'},{selectall:false,alias:3, name:'&#62;= 2 and &#60; 5 mm'},{selectall:false,alias:4, name:'&#60; 2 mm'},{selectall:false,alias:5, name:'&#62;= 5 and &#60; 20 mm'},{selectall:false,alias:6, name:'&#62;=20mm'},{selectall:false,alias:7, name:'Damaged'},{selectall:false,alias:99, name:'ND'}])}"/>
					</s:HGroup>
				</s:VGroup>
				
				<s:VGroup includeInLayout="{ichOptions}" id="ichGroup" width="100%"  gap="10" horizontalAlign="center"  verticalAlign="middle">
					<s:HGroup width="100%" gap="4" horizontalAlign="left" visible="{ichOptions}" includeInLayout="{ichOptions}" verticalAlign="middle">
						<s:HGroup width="375" verticalAlign="middle">
							<s:Label width="130" color="0xA80000" fontWeight="bold" text="Species Name:"/>
							<MultiDropDown:ComboCheck width="230" deselectAll="{speciesIch.selectedAll = false}" selectAll="{speciesIch.selectedAll = true}" id="speciesIch" selectAllLabelField="selectall" labelField="alias" dataProvider="{speciesIchArray}"/>
						</s:HGroup>
						<s:Label width="53" color="0xA80000" fontWeight="bold" text="Stage:" visible="{!microZoopVisible}"/>
						<MultiDropDown:ComboCheck width="143" deselectAll="{stageIch.selectedAll = false}" selectAll="{stageIch.selectedAll = true}" visible="{!microZoopVisible}" id="stageIch" selectAllLabelField="selectall" labelField="alias" 
												  dataProvider="{new ArrayCollection([{selectall:true, alias:'SELECT ALL'},{selectall:false, alias:'Adult'},{selectall:false, alias:'Egg'},{selectall:false, alias:'Egg/Larv'},{selectall:false, alias:'Juvenile'},{selectall:false, alias:'Larvae'},{selectall:false, alias:'Larv/Juv'},{selectall:false, alias:'egg stage 1'},{selectall:false, alias:'egg stage 2'},{selectall:false, alias:'egg stage 3'},{selectall:false, alias:'egg stage 4'},{selectall:false, alias:'egg stage 5'},{selectall:false, alias:'egg stage 6'},{selectall:false, alias:'egg stage 7'},{selectall:false, alias:'egg stage 8'},{selectall:false, alias:'egg stage 9'},{selectall:false, alias:'egg stage 10'},{selectall:false, alias:'egg stage 11'},{selectall:false, alias:'egg stage 12'},{selectall:false, alias:'egg stage 13'},{selectall:false, alias:'egg stage 14'},{selectall:false, alias:'egg stage 15'},{selectall:false, alias:'egg stage 16'},{selectall:false, alias:'egg stage 17'},{selectall:false, alias:'egg stage 18'},{selectall:false, alias:'egg stage 19'},{selectall:false, alias:'egg stage 20'},{selectall:false, alias:'egg stage 21'},{selectall:false, alias:'egg stage 22'},{selectall:false, alias:'egg stage 23'},{selectall:false, alias:'egg stage 24'}])}"/>
					</s:HGroup>
					<!--<s:HGroup width="100%" gap="10" horizontalAlign="left" visible="{ichOptions}" includeInLayout="{ichOptions}" verticalAlign="middle">
						<s:HGroup width="280" verticalAlign="middle">
							<s:Label width="150" color="0xA80000" fontWeight="bold" text="Min Volume Displacement:"/>
							<s:NumericStepper width="65" id="minDispIch" maximum="5000" minimum="-1000" value="0"/>
						</s:HGroup>
						<s:Label width="160" color="0xA80000" fontWeight="bold" text="Max Volume Displacement:"/>
						<s:NumericStepper id="maxDispIch" width="65" value="3400" minimum="-1000" maximum="5000"/>
						<s:CheckBox id="showallDispIch"  label="All" selected="false"/>
					</s:HGroup>-->
				</s:VGroup>
				
				<s:VGroup includeInLayout="{trawlOptions}" id="trawlGroup" width="100%" gap="10"  horizontalAlign="center"  verticalAlign="middle">
					<s:HGroup width="100%" gap="10" horizontalAlign="left" visible="{trawlOptions}" includeInLayout="{trawlOptions}" verticalAlign="middle">
						<s:HGroup width="280" verticalAlign="middle">
							<s:Label width="130" color="0xA80000" fontWeight="bold" text="Min Total Length(mm):"/>
							<s:NumericStepper width="65" id="minleng" maximum="3000" minimum="0" value="100"/>
						</s:HGroup>
						<s:Label width="160" paddingLeft="4" color="0xA80000" fontWeight="bold" text="Max Total Length(mm):"/>
						<s:NumericStepper id="maxleng" width="65" value="2000" minimum="0" maximum="3000"/>
						<s:CheckBox id="showallLeng"  label="All Lengths" selected="true"/>
					</s:HGroup>
					<s:HGroup width="100%" gap="15" horizontalAlign="left" visible="{trawlOptions}" includeInLayout="{trawlOptions}" verticalAlign="middle">
						<s:HGroup width="330" verticalAlign="middle">
							<s:Label width="130" color="0xA80000" fontWeight="bold" text="Species Name:"/>
							<MultiDropDown:ComboCheck width="255" deselectAll="{speciesTra.selectedAll = false}" selectAll="{speciesTra.selectedAll = true}" id="speciesTra" selectAllLabelField="selectall" labelField="alias" dataProvider="{speciesTrawlArray}"/>
						</s:HGroup>
					</s:HGroup>
				</s:VGroup>
				<s:VGroup width="100%" gap="10"  paddingTop="7"  horizontalAlign="left" paddingBottom="5" verticalAlign="middle">
					<s:HGroup width="100%" gap="15" horizontalAlign="left" includeInLayout="{sampleSearch}" visible="{sampleSearch}" verticalAlign="middle">
						<s:HGroup width="280" verticalAlign="middle" id="sampleBlock">
							<s:Label width="155" color="black" fontSize="14" fontWeight="bold" text="Choose Sample Type:"/>
							<!--<MultiDropDown:ComboCheck width="133"  selectAllLabelField="selectall" labelField="name" 
													  deselectAll="{databaseTextSamp.selectedAll = false}" selectAll="{databaseTextSamp.selectedAll = true}" id="databaseTextSamp" enabled="true" 
													  dataProvider="{new ArrayCollection([{selectall:true, alias:'SELECT ALL', name:'SELECT ALL'},
													  {selectall:false, name:'Zooplankton', alias:'1,4'},{selectall:false, alias:'2,4',name:'Ichthyoplankton'},
													  {selectall:false,alias:'3', name:'TRAWL'},{selectall:false,alias:'5', name:'SEACAT'},
													  {selectall:false,alias:'6', name:'CTD Bottle'},{selectall:false,alias:'7', name:'Phys Ocean'},
													  {selectall:false,alias:'8', name:'Benthic'},{selectall:false,alias:'9', name:'Biological'},
													  {selectall:false,alias:'10', name:'Other'},{selectall:false,alias:'11', name:'Discard'},
													  {selectall:false,alias:'12', name:'NONE'},{selectall:false,alias:'13', name:'Not Sure'}])}"/>-->
							<mx:ComboBox fontWeight="bold" id="databaseTextSamp">
								<s:ArrayCollection>
									<fx:Object label="Zooplankton" data="1,4"/>
									<fx:Object label="Ichthyoplankton" data="2,4"/>
									<fx:Object label="TRAWL" data="3"/>
									<fx:Object label="SEACAT" data="5"/>
									<fx:Object label="CTD Bottle" data="6"/>
									<fx:Object label="Phys Ocean" data="7"/>
									<fx:Object label="Benthic" data="8"/>
									<fx:Object label="Biological" data="9"/>
									<fx:Object label="Other" data="10"/>
									<fx:Object label="Discard" data="11"/>
									<fx:Object label="NONE" data="12"/>
									<fx:Object label="Not Sure" data="13"/>
								</s:ArrayCollection>
							</mx:ComboBox>
						</s:HGroup>
						<s:Label width="130" color="0xA80000" fontWeight="bold" text="Haul Performance:"/>
						<MultiDropDown:ComboCheck deselectAll="{haulPerTextSample.selectedAll = false}" selectAll="{haulPerTextSample.selectedAll = true}" id="haulPerTextSample" selectAllLabelField="selectall" labelField="alias" dataProvider="{new ArrayCollection([{selectall:true, alias:'SELECT ALL'},{selectall:false, alias:'GOOD'},{selectall:false, alias:'LOST'},{selectall:false, alias:'FAIL'},{selectall:false, alias:'QUEST'}])}"/>
					</s:HGroup>
					<s:HGroup width="100%" gap="15" horizontalAlign="left"  verticalAlign="middle">
						<s:HGroup width="280" verticalAlign="middle">
							<s:Label width="130" color="0xA80000" fontWeight="bold" text="Cruise:"/>
							<MultiDropDown:ComboCheck deselectAll="{cruiseSample.selectedAll = false}" selectAll="{cruiseSample.selectedAll = true}" id="cruiseSample" selectAllLabelField="selectall" labelField="alias" dataProvider="{cruiseArray}"/>
						</s:HGroup>
						<s:Label width="130" color="0xA80000" fontWeight="bold" text="Gear Abbreviation:"/>
						<MultiDropDown:ComboCheck deselectAll="{gearSample.selectedAll = false}" selectAll="{gearSample.selectedAll = true}" id="gearSample" selectAllLabelField="selectall" labelField="alias" 
												  dataProvider="{gearnamesArray}"/>
					</s:HGroup>
					<s:HGroup width="100%" gap="15" horizontalAlign="left" includeInLayout="{microZoopVisible==false &amp;&amp; hideotherOptions}" visible="{microZoopVisible==false &amp;&amp; hideotherOptions}" verticalAlign="middle">
						<s:HGroup width="280" verticalAlign="middle">
							<s:Label width="130" color="0xA80000" fontWeight="bold" text="Project:"/>
							<MultiDropDown:ComboCheck deselectAll="{projectSample.selectedAll = false}" selectAll="{projectSample.selectedAll = true}" id="projectSample" selectAllLabelField="selectall" labelField="alias" 
													  dataProvider="{new ArrayCollection([{selectall:true, alias:'SELECT ALL'},{selectall:false, alias:'BEST'},{selectall:false, alias:'BEST/BSIER'},{selectall:false, alias:'BOE'},{selectall:false, alias:'CHAOZ'},{selectall:false, alias:'CREP'},{selectall:false, alias:'Eco-FOCI'},{selectall:false, alias:'FOCI'},{selectall:false, alias:'FOCI/NPCRE'},{selectall:false, alias:'GLOBEC'},{selectall:false, alias:'GOAIERP'},{selectall:false, alias:'MISC'},{selectall:false, alias:'NPCREP'},{selectall:false, alias:'NPMRP'},{selectall:false, alias:'RUSALCA'},{selectall:false, alias:'SEBSCC'},{selectall:false, alias:'SSL'}])}"/>
						</s:HGroup>
						<s:Label width="130" color="0xA80000" fontWeight="bold" text="Purpose:"/>
						<MultiDropDown:ComboCheck deselectAll="{purposeSample.selectedAll = false}" selectAll="{purposeSample.selectedAll = true}" id="purposeSample" selectAllLabelField="selectall" labelField="alias" 
												  dataProvider="{new ArrayCollection([{selectall:true, alias:'SELECT ALL'},{selectall:false, alias:'ADULT'},{selectall:false, alias:'DIEL'},{selectall:false, alias:'DRIFT'},{selectall:false, alias:'DRIP'},{selectall:false, alias:'GEAR'},{selectall:false, alias:'GRID'},{selectall:false, alias:'GRIDPOST'},{selectall:false, alias:'GRIDPRE'},{selectall:false, alias:'JUVSURV'},{selectall:false, alias:'PLNKSURV'},{selectall:false, alias:'PHYS'},{selectall:false, alias:'OTHER'}])}"/>
					</s:HGroup>
					<s:HGroup width="100%" gap="15" horizontalAlign="left" includeInLayout="{hideotherOptions}" visible="{hideotherOptions}" verticalAlign="middle">
						<s:HGroup width="280" verticalAlign="middle">
							<s:Label width="130" color="0xA80000" fontWeight="bold" text="Mesh:"/>
							<MultiDropDown:ComboCheck deselectAll="{meshSample.selectedAll = false}" selectAll="{meshSample.selectedAll = true}" id="meshSample" selectAllLabelField="selectall" labelField="alias" 
													  dataProvider="{new ArrayCollection([{selectall:true, alias:'SELECT ALL'},{selectall:false, alias:'0'},{selectall:false, alias:'3'},{selectall:false, alias:'32'},{selectall:false, alias:'41'},{selectall:false, alias:'53'},{selectall:false, alias:'150'},{selectall:false, alias:'153'},{selectall:false, alias:'215'},{selectall:false, alias:'253'},{selectall:false, alias:'300'},{selectall:false, alias:'333'},{selectall:false, alias:'335'},{selectall:false, alias:'500'},{selectall:false, alias:'505'},{selectall:false, alias:'1000'},{selectall:false, alias:'1153'},{selectall:false, alias:'1410'},{selectall:false, alias:'1500'},{selectall:false, alias:'3000'},{selectall:false, alias:'6000'},{selectall:false, alias:'32000'}])}"/>
						</s:HGroup>
						<s:Label width="130" color="0xA80000" fontWeight="bold" text="NET:"/>
						<MultiDropDown:ComboCheck deselectAll="{netSample.selectedAll = false}" selectAll="{netSample.selectedAll = true}" id="netSample" selectAllLabelField="selectall" labelField="alias" 
												  dataProvider="{new ArrayCollection([{selectall:true, alias:'SELECT ALL'},{selectall:false, alias:'1'},{selectall:false, alias:'2'},{selectall:false, alias:'3'},{selectall:false, alias:'4'},{selectall:false, alias:'5'},{selectall:false, alias:'6'},{selectall:false, alias:'7'},{selectall:false, alias:'8'},{selectall:false, alias:'9'}])}"/>
					</s:HGroup>
					<s:HGroup width="100%" gap="10" horizontalAlign="left" visible="{microZoopVisible==false &amp;&amp; haulSearch ==false}" includeInLayout="{microZoopVisible==false &amp;&amp; haulSearch ==false}" verticalAlign="middle">
						<s:HGroup width="285" verticalAlign="middle">
							<s:Label width="130" color="0xA80000" fontWeight="bold" text="Min Bottom Depth(m):"/>
							<s:NumericStepper width="65" id="minDep" maximum="2000" value="0"/>
						</s:HGroup>
						<s:Label width="134" color="0xA80000" fontWeight="bold" text="Max Bottom Depth(m):"/>
						<s:NumericStepper id="maxDep" width="65" value="1400"  maximum="2000"/>
						<s:CheckBox id="showallDep" label="All Depths" selected="true"/>
					</s:HGroup>
					<s:HGroup width="100%" gap="10" horizontalAlign="left" visible="{haulSearch ==false}" includeInLayout="{haulSearch ==false}" verticalAlign="middle">
						<s:HGroup width="285" verticalAlign="middle">
							<s:Label width="130" color="0xA80000" fontWeight="bold" text="MIN (max) Gear Depth(m):"/>
							<s:NumericStepper width="65" id="minDepGear" maximum="2000" value="0"/>
						</s:HGroup>
						<s:Label width="134" color="0xA80000" fontWeight="bold" text="MAX (max) Gear Depth(m):"/>
						<s:NumericStepper id="maxDepGear" width="65" value="1400"  maximum="2000"/>
						<s:CheckBox id="showallDepGear" label="All Depths" selected="true"/>
					</s:HGroup>
					<s:HGroup width="100%" gap="15" horizontalAlign="left"  verticalAlign="middle">
						<s:HGroup width="280" verticalAlign="middle">
							<s:Label width="130" color="0xA80000" fontWeight="bold" text="HAUL ID:"/>
							<mx:TextInput id="haulSample" toolTip="Optional" width="130" />
						</s:HGroup>
						<s:Label width="130" color="0xA80000" fontWeight="bold" text="Sample ID:"/>
						<mx:TextInput id="sampleSample" toolTip="Optional"  width="135"/>
					</s:HGroup>
					<s:HGroup width="100%" gap="15" horizontalAlign="left"  verticalAlign="middle">
						<s:HGroup width="280" verticalAlign="middle">
							<s:Label width="130" color="0xA80000" fontWeight="bold" text="Geographic Area:"/>
							<MultiDropDown:ComboCheck width="130" deselectAll="{geolocSample.selectedAll = false}" labelField="alias" selectAll="{geolocSample.selectedAll = true}" id="geolocSample" selectAllLabelField="selectall" />
						</s:HGroup>
						<s:Label width="130" includeInLayout="{microZoopVisible==false}" visible="{microZoopVisible==false}" color="0xA80000" fontWeight="bold" text="Station Name:"/>
						<mx:TextInput id="stationN" includeInLayout="{microZoopVisible==false}" visible="{microZoopVisible==false}" toolTip="Optional"  width="135"/>
					</s:HGroup>
				</s:VGroup>
			</s:VGroup>		
			<s:HGroup paddingTop="1">
				<s:VGroup gap="10" paddingTop="20">
					<s:Label paddingLeft="50" id="resultLoc" text="*Results will be shown on map and in table." fontStyle="italic" fontSize="13" color="0xFFFFFF"/>
					<s:HGroup width="100%" horizontalAlign="center" gap="6"  verticalAlign="middle">
						<s:Button fontWeight="bold" id="timeButton" includeInLayout="{multipleSearch}" visible="{multipleSearch}" label="Define Time Range" toolTip="Set Time Range" click="showTimeSettings()" />
						<s:Button fontWeight="bold" id="relateButton" includeInLayout="{associationOptions}" visible="{associationOptions}" label="View associated Records*" toolTip="View Records associated with existing Query" click="selectRelationshipData()" />
						<s:Button fontWeight="bold" color="red" id="searchBtn" label="{submitLabel}"/>
						<s:Button fontWeight="bold" click="showfields()" label="Select Fields"/>
						<s:Button fontWeight="bold" click="clear()" label="{clearLabel}"/>
						<!--<s:CheckBox fontWeight="bold" id="catchzero" label="Catch w/ Zeros" toolTip="Table will be downloaded.  Only one Species name can be used" visible="{cboLayerText.selectedIndex == 1}" includeInLayout="{cboLayerText.selectedIndex == 1}"/>-->
						
					</s:HGroup>
					<s:HGroup width="100%" horizontalAlign="center" gap="6"  verticalAlign="middle">
						<s:Button fontWeight="bold" click="generateCatch()" id="catchzero" label="Catch w/ Zeros" toolTip="Table will be downloaded.  Only one Species name can be used" visible="{cboLayerText.selectedIndex == 1}" includeInLayout="{cboLayerText.selectedIndex == 1}"/>
						<s:Button fontWeight="bold" click="generateTrawlLength()" id="trawl_length_but" label="Trawl Length" toolTip="Table will be downloaded.  " visible="{cboLayerText.selectedIndex == 1}" includeInLayout="{cboLayerText.selectedIndex == 1}"/>
						<s:Button fontWeight="bold" click="generateIchLength()" id="ich_length_but" label="Ich Length" toolTip="Table will be downloaded.  " visible="{cboLayerText.selectedIndex == 3}" includeInLayout="{cboLayerText.selectedIndex == 3}"/>
						<s:Button fontWeight="bold" click="generateIchAbundance()" id="ich_abundance_but" label="Ich Abundance" toolTip="Table will be downloaded." visible="{cboLayerText.selectedIndex == 3}" includeInLayout="{cboLayerText.selectedIndex == 3}"/>
					</s:HGroup>
					<s:Label id="dataproc_status" paddingLeft="100" includeInLayout="false" text="Your Processing Tool is running..." fontSize="11" color="0xFF0000"/>
					<s:Label includeInLayout="{associationOptions}" visible="{associationOptions}" text="*This will return all associated records with subsample search." fontStyle="italic" fontSize="13" color="0xFFFFFF"/>
				</s:VGroup>
			</s:HGroup>
		</s:Group>
		
		<!-- Field Settings-->
		<s:Group id="fieldInput"
				 width="100%" height="100%"
				 visible="false"
				 visible.fieldInput="true">
			<s:layout>
				<s:HorizontalLayout gap="15" paddingTop="12" horizontalAlign="center"/>
			</s:layout>
			<s:VGroup gap="19" paddingTop="50" horizontalAlign="center">
				<s:Label color="0xA80000" fontWeight="bold" text="Select Column Fields to view in Table" fontSize="14"/>
				<s:HGroup verticalAlign="middle">
					<s:Label text="Preset Field List:" fontWeight="bold" paddingRight="4"/>
					<mx:ComboBox id="sampleTypeList" dataProvider="{['NONE','ICH','ZOOP','TRAWL']}" change="sampleTypeList_changeHandler(event)" />
				</s:HGroup>
				<s:Button fontWeight="bold" includeInLayout="{multipleSearch}" visible="{multipleSearch}" label="Define Time Range" toolTip="Set Time Range" click="showTimeSettings()" />
				<s:Button fontWeight="bold" label="Back to Text Search" toolTip="Go back to make other changes" click="showStateTextSearch()" />
				<s:Button fontWeight="bold" color="red" label="Process Search" toolTip="Process Search" click="queryFeaturesText2()" />
			</s:VGroup>
			<mx:DataGrid id="dg" horizontalGridLines="true" verticalGridLines="true" allowMultipleSelection="true" headerHeight="25"  rowCount="19" headerStyleName="accHead" width="245">
				<mx:columns>
					<mx:DataGridColumn sortable="false" width="29" textAlign="center">
						<mx:headerRenderer>
							<fx:Component>
								<mx:CheckBox toolTip="Select All Fields" paddingLeft="7" click="outerDocument.checkAll(event)"/>
							</fx:Component>
						</mx:headerRenderer>
						<mx:itemRenderer>
							<fx:Component>
								<mx:CheckBox toolTip="Select This Field" paddingLeft="7" selected="{(data.gridfield == 'true')?true:false}" click="{data.gridfield = (data.gridfield != 'true') ? 'true' : 'false';}"/>
							</fx:Component>
						</mx:itemRenderer>
					</mx:DataGridColumn>
					<mx:DataGridColumn dataField="alias" headerText="Attribute Fields" />
				</mx:columns>
			</mx:DataGrid>
		</s:Group>
		
		<!-- TimeSettings-->
		<s:Group id="timeInput"
				 width="100%" height="100%"
				 visible="false"
				 visible.timeInput="true">
			<s:layout>
				<s:VerticalLayout gap="1"/>
			</s:layout>
			<s:Label text="Time Settings" color="0xA80000" fontWeight="bold" fontSize="16" paddingLeft="1" paddingTop="14" paddingBottom="10" />
			<s:Label text="Select Year(s), Month(s) and Day Range(s) Criteria for Search" color="0xA80000" fontSize="14" paddingLeft="15" paddingTop="14" paddingBottom="15" />
			<s:HGroup verticalAlign="middle" paddingTop="15" paddingLeft="15" gap="25" horizontalAlign="center">
				<s:VGroup>
					<s:Label text="Select Years" color="0xA80000"  fontSize="14" paddingLeft="5" paddingTop="15" />
					<mx:DataGrid  id="dgYear" horizontalGridLines="true" verticalGridLines="true" allowMultipleSelection="true" headerHeight="30"  rowCount="10" headerStyleName="accHead" width="165" dataProvider="{yearArray}">
						<mx:columns>
							<mx:DataGridColumn sortable="false" width="29" textAlign="center">
								<mx:headerRenderer>
									<fx:Component>
										<mx:CheckBox toolTip="Select all Years" paddingLeft="7" click="outerDocument.checkAllyear(event)"/>
									</fx:Component>
								</mx:headerRenderer>
								<mx:itemRenderer>
									<fx:Component>
										<mx:CheckBox toolTip="Select This Year" paddingLeft="7" selected="{(data.gridfield == 'true')?true:false}" click="{data.gridfield = (data.gridfield != 'true') ? 'true' : 'false';}"/>
									</fx:Component>
								</mx:itemRenderer>
							</mx:DataGridColumn>
							<mx:DataGridColumn dataField="alias" headerText="Year" />
						</mx:columns>
					</mx:DataGrid>
				</s:VGroup>
				<s:VGroup>
					<s:Label text="Select Months" color="0xA80000" fontSize="14" paddingLeft="5" paddingTop="15" />	
					<mx:DataGrid  id="dgMonth" horizontalGridLines="true" dataProvider="{monthArray}" verticalGridLines="true" allowMultipleSelection="true" headerHeight="30"  rowCount="10" headerStyleName="accHead" width="165">
						<mx:columns>
							<mx:DataGridColumn sortable="false" width="29" textAlign="center">
								<mx:headerRenderer>
									<fx:Component>
										<mx:CheckBox selected="true" toolTip="Select all Months" paddingLeft="7" click="outerDocument.checkAllmonth(event)"/>
									</fx:Component>
								</mx:headerRenderer>
								<mx:itemRenderer>
									<fx:Component>
										<mx:CheckBox toolTip="Select This Months" paddingLeft="7" selected="{(data.gridfield == 'true')?true:false}" click="{data.gridfield = (data.gridfield != 'true') ? 'true' : 'false';}"/>
									</fx:Component>
								</mx:itemRenderer>
							</mx:DataGridColumn>
							<mx:DataGridColumn dataField="alias" headerText="Months" />
						</mx:columns>
					</mx:DataGrid>
				</s:VGroup>
				<s:VGroup>
					<s:Label text="Select Days" color="0xA80000" fontSize="14" paddingLeft="5" paddingTop="15" />
					<mx:DataGrid  id="dgDay" horizontalGridLines="true" dataProvider="{dayArray}" verticalGridLines="true" allowMultipleSelection="true" headerHeight="30"  rowCount="10" headerStyleName="accHead" width="165" >
						<mx:columns>
							<mx:DataGridColumn sortable="false" width="29" textAlign="center">
								<mx:itemRenderer>
									<fx:Component>
										<mx:CheckBox toolTip="Select This Day" paddingLeft="7" selected="{(data.gridfield == 'true')?true:false}" click="{data.gridfield = (data.gridfield != 'true') ? 'true' : 'false';}"/>
									</fx:Component>
								</mx:itemRenderer>
							</mx:DataGridColumn>
							<mx:DataGridColumn dataField="alias" headerText="Days" />
						</mx:columns>
					</mx:DataGrid>
				</s:VGroup>
			</s:HGroup>
			<s:VGroup paddingTop="60" horizontalAlign="center" width="100%">
				<s:HGroup paddingTop="10" horizontalAlign="center" gap="20">
					<s:Button fontWeight="bold" label="Back to Text Search" toolTip="Go back to make other changes" click="showStateTextSearch()" />
					<s:Button fontWeight="bold" label="Process Search" color="red" toolTip="Process Search" click="queryFeaturesText2()" />
					<s:Button fontWeight="bold" click="showfields()" label="Select Fields"/>
				</s:HGroup>
			</s:VGroup>
		</s:Group>
		
		<!-- result-->
		<s:Group id="resultsList"
				 width="100%" height="100%"
				 visible="false"
				 visible.resultsList="true">
			<s:layout>
				<s:VerticalLayout gap="1"/>
			</s:layout>
			<s:Label text="Results and Statistics" color="0xA80000" fontWeight="bold" fontSize="16" paddingLeft="5" paddingTop="10" />
			<s:HGroup id="boxMessage"
					  width="100%" paddingTop="20"
					  includeInLayout="{msgVisible}"
					  visible="{msgVisible}" verticalAlign="middle" horizontalAlign="center">
				<mx:Image id="swfMessage"
						  source="assets/images/loader.swf"
						  visible="false"/>
				<s:Label id="txtMessage"
						 width="90%"
						 text=""/>
				<s:Button click="showStateTextSearch2()"
						 fontWeight="bold" fontSize="14"
						 label="Back to Search"
						 toolTip="Search Again"
						 visible="true"/>
				<s:Button click="clear()"
						 fontWeight="bold"
						 includeInLayout="{searchResultAC.length &gt; 0}"
						 label="{clearLabel}" fontSize="13"
						 visible="{searchResultAC.length &gt; 0}"/>
			</s:HGroup>
			<s:VGroup paddingTop="40" width="100%">
				<s:Label text="Query Summary" fontSize="13" paddingLeft="5" color="0xA80000" fontWeight="bold" paddingTop="5"/>
				<s:Label id="querySum" text="There is no current search." fontSize="12" paddingLeft="25" width="100%" paddingTop="5"/>
				<mx:CheckBox paddingLeft="25" paddingTop="0" enabled="false" disabledColor="0xE5ECFF" fontWeight="bold" label="View Individual Result Points" selected="false" id="unclusterCheck" click="unclusterPoints()" toolTip="Uncluster Results to view Individual Points. Individual points can slow down application.  Only available if total number of features is less than 3200."/>
			</s:VGroup>
		</s:Group>
	</viewer:WidgetTemplate>
</viewer:BaseWidget>